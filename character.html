<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/dev-test/Character%20Tools/Assets/BookmarkingToolIcon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="pinterest" content="nopin" />
    <title>Character Bookmarking Tool</title>
    <style>
    
.theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #import-btn, #tile-size, #colorSelector, #popup-button, #reroll-btn, #local-upload-btn, #url-upload-btn,
#url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, #url-popup-close-url1, #popup-close, .collapsible, .edit-popup button,
#submit-url-btn, #submit-url-btn1, #share-url-popup button, #nsfw-inclusion-popup button, #image-upload-choice-popup button, #tile-creation-popup button, #settings-popup button, 
#tileSize, #undo-delete-popup button, #popup-close-btn {
	background-color: var(--button-bg-1);
}

#character-popup {
	width: 90%;
	max-width: 600px;
	margin: 0 auto;
}

#popup-content {
    overflow-y: auto;
	display: flex;
	flex-direction: column;
	align-items: center;
	width: 100%
}

#tile-creation-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
}

#tile-creation-popup input, #tile-creation-popup textarea {
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

#tile-creation-popup button {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	margin-top: 10px;
    width: 100%
}

.info-section {
	background-color: var(--tile-bg);
	border-radius: 15px;
	padding: 20px;
	margin: 20px 0;
	box-shadow: 0 4px 6px var(--tile-shadow);
	font-family: 'Arial', sans-serif;
	line-height: 1.6;
	max-width: 800px;
	margin-left: auto;
	margin-right: auto;
}

.info-section h2 {
	color: var(--button-bg);
	font-size: 1.8em;
	margin-bottom: 15px;
	text-align: center;
	text-transform: uppercase;
	letter-spacing: 2px;
}

.info-section p {
	margin-bottom: 15px;
	text-align: justify;
}

.info-section ul {
	list-style-type: none;
	padding-left: 20px;
}

.info-section li {
	position: relative;
	padding-left: 25px;
	margin-bottom: 10px;
}

.info-section li::before {
	content: '✦';
	position: absolute;
	left: 0;
	color: var(--button-bg);
}

.highlight {
	background-color: var(--button-bg-1);
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-nsfw {
	background-color: var(--nsfw-color-1);
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-favourite {
	background-color: green;
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-special {
	background-color: purple;
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

:root {
	--button-bg-1: #3e6e3e;
	--button-bg-2: #4c6b3b;
	--button-bg-3: #5c8a3b;
	--button-bg-4: #3e6e96;

	--button-bg-hover-1: #2c5a2c;
	--button-bg-hover-2: #3b5a32;
	--button-bg-hover-3: #4a6a32;
	--button-bg-hover-4: #2c5a74;

	--nsfw-color-1: #FF1A1A;
	--nsfw-color-2: #FF6A6A;
	--nsfw-color-3: #FF7F7F;
	--nsfw-color-4: #FF6A6A;

	--special-outline-color-1: #3B0056;
	--special-outline-color-2: #A88DFF;
	--special-outline-color-3: #9C51C4;
	--special-outline-color-4: #7B5DAF;

	--star-outline-color-1: #2E5B2E;
	--star-outline-color-2: #7B6B3A;
	--star-outline-color-3: #B7C20E;
	--star-outline-color-4: #4E4B31;

	--bg-color: #f4f4f4;
	--text-color: #333;
	--tile-bg: #fff;
	--tile-shadow: rgba(0, 0, 0, 0.1);
	--add-tile-bg: #e0e0e0;
	--add-tile-hover: #d0d0d0;
	--button-color: white;
	--popup-color: #dfdfdf;
}

.dark-mode {

	--button-bg-1: #4f8b4f;
	--button-bg-2: #5f8b4f;
	--button-bg-3: #6f9b4f;
	--button-bg-4: #4f8b96;

	--button-bg-hover-1: #3e6b3e;
	--button-bg-hover-2: #4d6b3e;
	--button-bg-hover-3: #5c7b3e;
	--button-bg-hover-4: #3e6b8a;

	--nsfw-color-1: #FF7F7F;
	--nsfw-color-2: #FF8A8A;
	--nsfw-color-3: #FF8A8A;
	--nsfw-color-4: #FF8A8A;

	--special-outline-color-1: #D78FFF;
	--special-outline-color-2: #D6A5FF;
	--special-outline-color-3: #A66CBB;
	--special-outline-color-4: #B57EDB;

	--star-outline-color-1: #A8FF4C;
	--star-outline-color-2: #B7B73A;
	--star-outline-color-3: #D2D700;
	--star-outline-color-4: #7A7B35;
	--bg-color: #333;
	--text-color: #f4f4f4;
	--tile-bg: #555;
	--tile-shadow: rgba(0, 0, 0, 0.3);
	--add-tile-bg: #444;
	--add-tile-hover: #666;
	--button-color: #f4f4f4;
	--popup-color: #2f2f2f;
}

.amoled-mode {

	--button-bg-1: #2e5e2e;
	--button-bg-2: #3e5e2e;
	--button-bg-3: #4e6e2e;
	--button-bg-4: #2e5e6a;

	--button-bg-hover-1: #3e6b3e;
	--button-bg-hover-2: #4d6b3e;
	--button-bg-hover-3: #5c7b3e;
	--button-bg-hover-4: #3e6b8a;

	--nsfw-color-1: #C05050;
	--nsfw-color-2: #C06A6A;
	--nsfw-color-3: #D06A6A;
	--nsfw-color-4: #C0507A;

	--special-outline-color-1: #A052B1;
	--special-outline-color-2: #A06EB1;
	--special-outline-color-3: #B06EB1;
	--special-outline-color-4: #A052C6;

	--star-outline-color-1: #7D9A3C;
	--star-outline-color-2: #8B9A3C;
	--star-outline-color-3: #9B9A3C;
	--star-outline-color-4: #7D9A6A;

	--bg-color: #000;
	--text-color: #e0e0e0;
	--tile-bg: #111;
	--tile-shadow: rgba(255, 255, 255, 0.1);
	--add-tile-bg: #222;
	--add-tile-hover: #333;
	--button-color: #e0e0e0;
	--popup-color: #111;
}

body {
	font-family: Arial, sans-serif;
	line-height: 1.6;
	margin: 0;
	padding: 20px;
	background-color: var(--bg-color);
	color: var(--text-color);
	transition: background-color 0.3s, color 0.3s;
}

h1,
p {
	text-align: left;
}

.controls {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 20px;
}

#edit-info-popup input, #edit-info-popup textarea {
	width: 100%;
	box-sizing: border-box;
	margin-bottom: 10px;
}

.theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #import-btn, #tile-size {
	padding: 5px 10px;
	cursor: pointer;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	margin-right: 5px;
	margin-bottom: 10px;
}

#tag-filter-mobile {
	width: 100%;
	display: none;
}


.image-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	gap: 20px;
	padding: 20px;
}

.image-item {
	aspect-ratio: 1 / 1;
	position: relative;
	background-color: var(--tile-bg);
	border-radius: 8px;
	overflow: hidden;
	box-shadow: 0 2px 4px var(--tile-shadow);
}

.image-container {
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	overflow: hidden;
}

img {
	min-width: 100%;
	min-height: 100%;
	object-fit: cover;
	transition: transform 0.3s ease;
}

img:hover {
	transform: scale(1.05);
}

.add-image {
	display: flex;
	justify-content: center;
	align-items: center;
	background-color: var(--add-tile-bg);
	cursor: pointer;
	font-size: 48px;
	transition: background-color 0.3s ease;
}

.add-image:hover {
	background-color: var(--add-tile-hover);
}

#file-input, #import-file-input, .popup.hidden {
	display: none;
}

.hidden {
	display: none;
}

.tile-buttons {
	position: absolute;
	top: 5px;
	right: 5px;
	display: flex;
	flex-wrap: wrap;
}

.tile-buttons button {
	background-color: rgba(0, 0, 0, 0.5);
	color: white;
	border: none;
	border-radius: 50%;
	width: 30px;
	height: 30px;
	font-size: 15px;
	cursor: pointer;
	display: flex;
	justify-content: center;
	align-items: center;
	margin-left: 5px;
	margin-bottom: 5px;
}

.tags {
	position: absolute;
	bottom: 5px;
	left: 5px;
	display: flex;
	flex-wrap: wrap;
}

.tag {
	background-color: rgba(0, 0, 0, 0.5);
	color: white;
	padding: 2px 5px;
	border-radius: 3px;
	font-size: 12px;
	margin-right: 3px;
	margin-bottom: 3px;
}

.tag:hover {
	background-color: rgba(0, 0, 0, 0.7);
}

@media screen and (max-width: 600px) {
	.image-grid {
		grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
	}
}

#popup-close-btn {
	margin-top: 10px;
	padding: 5px 10px;
	color: white;
	border: none;
	border-radius: 5px;
	cursor: pointer;
    transition: background-color 0.3s;
}


.popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: flex;
	flex-direction: column;
	align-items: center;
	max-width: 800px;
	animation: float 5s ease-in-out infinite;
}

@keyframes float {
	0% {
		transform: translate(-50%, -50%);
	}

	50% {
		transform: translate(-50%, -52%);
	}

	100% {
		transform: translate(-50%, -50%);
	}
}

#popup-image-container {
	flex: 0 0 auto;
	margin-right: 20px;
}

#popup-content {
	position: relative;
}

#popup-image {
	min-width: unset;
	width: 250px;
	height: 250px;
	object-fit: cover;
	border-radius: 8px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	margin-bottom: 10px;
}

#popup-image {
	transform: scale(1)
}

.popup-info {
	flex: 1;
	background-color: rgba(255, 255, 255, 0.1);
	border-radius: 8px;
	padding: 15px;
	overflow-y: auto;
	max-height: 225px;
	width: 100%;
}

.popup-info h3 {
	margin-top: 0;
	border-bottom: 1px solid rgba(255, 255, 255, 0.3);
	padding-bottom: 5px;
}

.popup-info p {
	margin: 10px 0;
}

#popup-tags {
	font-style: italic;
}

#popup-button, #reroll-btn, #popup-close-btn {
	display: inline-block;
	margin-top: 15px;
	color: var(--button-color);
	padding: 8px 15px;
	border-radius: 4px;
	text-decoration: none;
	transition: background-color 0.3s;
	margin-bottom: 10px;
	border-color: transparent;
    width: 100%
}

#local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, #url-popup-close-url1 {
	display: inline-block;
	cursor: pointer;
	color: var(--button-color);
	padding: 8px 15px;
	border-radius: 4px;
	text-decoration: none;
	transition: background-color 0.3s;
	margin-bottom: 10px;
	border-color: transparent;
	width: 100%
}

#popup-close{
	position: absolute;
	top: -10px;
	right: -10px;
	color: var(--button-color);
	width: 30px;
	height: 30px;
	border-radius: 50%;
	display: flex;
	justify-content: center;
	align-items: center;
	cursor: pointer;
	font-size: 18px;
	font-weight: bold;
	transition: background-color 0.3s;
}


#popup-close-btn {
	display: none;
}

.popup-overlay {
	position: fixed;
	display: none;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 999;
	backdrop-filter: blur(5px);
}

.nsfw-outline, .popup.nsfw-outline {
	border: 5px solid var(--nsfw-color-1);
	/* Default color */
}

.blurred-image {
	filter: blur(10px);
}

.star-outline {
	border: 5px solid var(--star-outline-color-1);
}

.special-outline {
	border: 5px solid var(--special-outline-color-1);
}

.collapsible {
	color: var(--button-color);
	cursor: pointer;
	padding: 18px;
	width: 100%;
	border: none;
	text-align: left;
	outline: none;
	font-size: 15px;
	margin-bottom: 10px;
}

.collapsible:after {
	content: '\002B';
	color: var(--button-color);
	font-weight: bold;
	float: right;
	margin-left: 5px;
}

.active:after {
	content: "\2212";
}

.collapsible-content {
	padding: 0 18px;
	max-height: 0;
	overflow: hidden;
	transition: max-height 0.2s ease-out, padding 0.2s ease-out;
	background-color: var(--tile-bg);
	margin-bottom: 10px;
}

.edit-popup, #image-popup, #image-source-popup, #url-input-popup, #url-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
	animation: float 5s ease-in-out infinite;
}

.edit-popup input, .edit-popup textarea, #image-url-input1, #image-url-input{
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

.edit-popup button {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 100%;
	margin-top: 10px;
}

#submit-url-btn, #submit-url-btn1 {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 100%;
	margin-top: 10px;
	margin-bottom: 10px;
}

.image-grid {
	--tile-size: 200px;
	--grid-gap: 20px;
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(var(--tile-size), 1fr));
	gap: var(--grid-gap);
	padding: 20px;
}

#share-url-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
	animation: float 5s ease-in-out infinite;
}

#share-url-popup input {
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

#share-url-popup button {
	padding: 10px 20px;
	width: 100%;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	margin-top: 10px;
}

#nsfw-inclusion-popup, #settings-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
	animation: float 5s ease-in-out infinite
}

#nsfw-inclusion-popup button, #settings-popup button, #colorSelector, #tileSize {
	width: 100%;
	margin-top: 10px;
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
}

#image-upload-choice-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
}

#image-upload-choice-popup button {
	margin: 10px;
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 80%;
}

.theme-toggle button:hover, #tag-filter:hover, #tag-filter-mobile, #export-btn:hover, #import-btn:hover, #image-upload-choice-popup button:hover, #nsfw-inclusion-popup button:hover,
#share-url-popup button:hover, .edit-popup button:hover, .active, .collapsible:hover, #popup-close-btn:hover ,#popup-close:hover, #settings-popup button:hover, #undo-delete-popup button:hover {
	background-color: var(--button-bg-hover-1)
}

#undo-delete-popup {
	position: fixed;
	bottom: 20px;
	left: 20px;
	background-color: var(--popup-color);
	color: var(--text-color);
	padding: 15px;
	border-radius: 5px;
	display: flex;
	align-items: center;
	justify-content: space-between;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
	z-index: 1000;
	opacity: 0;
	transform: translateY(20px);
	transition: opacity 0.3s, transform 0.3s;
}

#undo-delete-popup.show {
	opacity: 1;
	transform: translateY(0);
}

#undo-delete-popup p {
	margin: 0;
	margin-right: 15px;
}

#undo-delete-popup button {
	color: white;
	border: none;
	padding: 5px 10px;
	border-radius: 3px;
	cursor: pointer;
	transition: background-color 0.3s;
}

#dismiss-undo {
	background-color: transparent !important;
	color: #aaa;
	padding: 0 !important;
	margin-left: 10px;
}

#dismiss-undo:hover {
	color: #fff;
}

@media (max-width: 650px) {
	#undo-delete-popup {
		bottom: 0;
		left: 0;
		width: 100%;
		margin-left: 0;
		transform: none;
		padding: 20px;
		box-sizing: border-box;
	}
}

@media (max-height: 670px) {
    #settings-popup{
        height: 600px
    }
}
@media (max-height: 570px) {
    #settings-popup{
        height: 500px
    }
}
@media (max-width: 600px) {
	#character-popup {
		max-height: 80vh;
		overflow-y: auto;
	}

    #popup-close-btn{
        display: block
    }
    #popup-close{
        display: none
    }

	#popup-image {
		max-height: 200px;
		width: auto;
		object-fit: contain;
	}

	.popup-info {
		max-height: none;
	}

	.edit-popup, #share-url-popup, #nsfw-inclusion-popup, #image-popup, #image-source-popup, #url-input-popup, #url-popup, #settings-popup, #tile-creation-popup {
		width: 80%;
		max-width: none;
		padding: 15px;
	}

	.edit-popup textarea, #nsfw-inclusion-popup button, #local-upload-btn, .edit-popup button, #share-url-popup button, #nsfw-inclusion-popup button, .theme-toggle button, 
    #export-btn, #import-btn, #tile-size, #tag-filter-mobile, #local-upload-btn, #url-upload-btn, #url-popup-close, #colorSelector, #settings-popup button, #tileSize {
		width: 100%;
		margin-bottom: 15px;
		padding: 15px;
	}
    .edit-popup input, #image-url-input1, #image-url-input, #tile-link, #tile-tags, #tile-name, #tile-platform, #tile-age, #tile-description{
        width: 93% !important;
    }

	#share-url-popup input {
		width: 80%;
		margin-bottom: 15px;
		padding: 15px;
	}

	#popup-content {
		flex-direction: column;
	}

	#popup-image-container {
		margin-right: 0;
		margin-bottom: 20px;
	}

	#popup-image {
		width: 100%;
		height: auto;
	}

	.popup-info {
		max-height: none;
	}

	.tile-buttons button {
		width: 40px;
		height: 40px;
	}

	#tag-filter-mobile {
		display: block;
	}

	.tag {
		padding: 4px 10px;
	}

	#tag-filter {
		display: none;
    }
}
    </style>
</head>
<body>
    <h1>Character Bookmarking Tool</h1>
    <h2>Welcome to the Character Bookmarking Tool</h2>
    <button class="collapsible">Click here for more information (recommended for first time users)</button>
    <div class="collapsible-content">
       <p>Ever wanted a singular place to save all your favourite, interesting characters? Does the platform you're using not have the ability to bookmark/favourite characters? This tool allows you to bookmark the character so you don't forget about it.</p>
       <p>To bookmark a character:</p>
       <ul>
          <li>Go to the end of the grid and click the tile with the <span class="highlight">+</span> icon.</li>
          <li>Once you prompt the tile curation, you'll be asked to upload a file from your system.</li>
          <li>The file upload prompt will by default show all the files that are supported by the system (though some of the supposed "supported" file formats like .psp may not work.)</li>
          <li>
             After uploading an image, you'll be prompted to include:
             <ul>
                <li>A hyperlink</li>
                <li>Tags</li>
                <li>Character name</li>
                <li>Platform</li>
                <li>Character age</li>
                <li>Character description</li>
             </ul>
          </li>
       </ul>
       <p><strong>Note:</strong> Not all of these are required, but at minimum the <span class="highlight">hyperlink</span> should be added so that you're able to go to the character page when you click the tile. The other information makes remembering the details of the characters easier.</p>
       <p><strong>How to edit information?</strong></p>
       <p>Once you've curated the tile, you'll be able to edit all the information that you had inputted when curating the tile:</p>
       <ul>
          <li>Choose <span class="highlight">Edit Image</span> to change the image that is attached to the tile.</li>
          <li>Choose <span class="highlight">Edit URL</span> to change the hyperlink that the tile will direct towards when clicked.</li>
          <li>Choose <span class="highlight">Edit Tags</span> to change the tags associated with the tile.</li>
          <li>Choose <span class="highlight">Edit Info</span> to change the name, platform, age, and description.</li>
       </ul>
       <p><strong>How to indicate characters as NSFW?</strong></p>
       <p>When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, add one of the following tags:</p>
       <ul>
          <li>NSFW</li>
          <li>Hentai</li>
          <li>18+</li>
          <li>Porn</li>
          <li>Yaoi</li>
          <li>🔞</li>
       </ul>
       <p>They're case sensitive, so put them in as shown here. This will cause a <span class="highlight-nsfw">red outline</span> to appear around the tile and the random character popup if it's selected. You can also blur the image with the <span class="highlight">Blur NSFW</span> button in the <span class="highlight">Theme Settings</span> menu.</p>
       <p>Like the favourite system (bellow) the <span class="highlight">NSFW</span> tag will show all the aobve NSFW tags, though each individual one will appear in the tag filtering dropdown.</p>
       <p><strong>How to indicate characters as Favourites?</strong></p>
       <p>When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, add one of the following tags. This will cause a <span class="highlight-favourite">green outline</span> to appear around the tile and random character popup if it's selected.</p>
       <ul>
        <li>⭐</li>
        <li>🌠</li>
        <li>🤩</li>
        <li>🌟</li>
        <li>✨</li>
        <li>💫</li>
        <li>❇️</li>
        <li>✴️</li>
        <li>✳️</li>
       </ul>
       <p>Note that regardless of which ones you use (either one exlusively or a combination) when using the tag filtering dropdown they will be combined to a singular <span class="highlight-favourite">⭐</class> section.</p>
       <p><strong>Can I indicate a character as being NSFW and a Favourite?</strong></p>
       <p>Yes! When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, adding one of the NSFW tag triggers and the Favourites tag trigger will cause a special <span class="highlight-special">purple outline</span> to appear on both the tile and random character popup if it's selected.</p>
       <p><strong>Should I Export?</strong></p>
       <p>Yes, it's recommended that you export your grid/list any time you make any changes to it. Everything is stored locally on the browser, so if anything happens (cookies reset, change browsers, change devices, etc...) the page will reset to be blank. If this happens, just use the Import button to bring back the characters. With the export/backup file, you'll also be able to use the Reorder Tool and Merge Tool.</p>
    </div>
    <button class="collapsible">Update Log</button>
    <div class="collapsible-content">
        <h2>Updpate 1.8</h2>
        <ul>
            <li>For the favourite tags, all will now appear under the ⭐ tag in the tag filtering dropdown.</li>
            <li>If there are no characters tagged as NSFW, the NSFW Inclusion prompt will not appear, allowing quicker access to the feature.</li>
            <li>If there are no characters that have NOT been tagged as NSFW, the NSFW Inclusion prompt will not appear, and <code>includeNSFW</code> will switch to true.</li>
            <li>Added an undo feature to remember the most recent deleted character, providing an opportunity to restore it.</li>
            <li>For Pinterest Extension users, the extension will no longer show up on the website, resolving issues with buttons covering site elements.</li>
            <li>Light Theme, Dark Mode, and AMOLED Mode buttons are now unified into a single button in the settings screen.</li>
            <li>You can now set the add-image tile to the beginning of the grid, while new tiles will still appear at the end.</li>
            <li>Fixed a bug where <code>.highlight</code> would not have a background color.</li>
        </ul>        
        <h2>Update 1.7.3</h2>
        <ul>
            <li>Added a new drop-down that will change the website's colors to make it more accessible for people with Deuteranopia, Protanopia, and Tritanopia.</li>
            <li>Added an AMOLED mode, which is a darker version of Dark Mode.</li>
            <li>Blur NSFW, Light Mode, Dark Mode, AMOLED Mode, and Color Blindness options are now combined into a new "Theme Settings" popup.</li>
            <li>The website will now remember if you had toggled to hide or show the tile buttons.</li>
            <li>The following emojis will now trigger the favorite character outline: ✨, 🌠, 🌟, 💫, 🤩, ❇️, ✴️, ✳️.</li>
            <li>Yaoi is now a trigger for the NSFW outline.</li>
            <li>Fixed issue where the overlay would continue to appear if you were to select exclude NSFW when there are no characters that don't have the NSFW tags.</li>
            <li>Updated the no non-NSFW character popup to include information about resetting the remembered state.</li>
          </ul>                 
        <h2>Update 1.7.2</h2>
        <ul>
            <li>Tag Filter dropdown now works on mobile</li>
            <li>For the share URL popup, the URL in the textbox should no longer be translated (resulting in it not appearing)</li>
            <li>Changed "Flush Remembered State" to "Reset Remembered State" since Flush didn't appear to translate correctly.</li>
            <li>Removed nsfw-preference-popup since it isn't used</li>
            <li>The buttons in the NSFW inclusion popup should now be centred</li>
            <li>Increased the size of the Select Image Source Popups on Mobile and Larger Screens</li>
            <li>Increased the spacing between certain buttons on mobile to make it more mobile responsive</li>
            <li>Increased the width of the Share URL buttons on larger screens</li>
            <li>The Copy URL button will no longer show a prompt that the url had been copied, it'll now appear as a console log (available through dev tools.)</li>
            <li>When curating a tile or editing the tags of an existing tile, if it includes both a trigger for the NSFW outline and Favourite Outline, it will now automatically switch it to the special outline instead of only applying after refresh</li>
            <li>When curating or editing a tile, all NSFW tag triggers should cause the outline to appear automatically instead of waiting for page refresh</li>
            <li>Changed the NSFW Outline, Favourite Outline, and Special Outline. They'll appear darker on light mode and lighter on dark mode. They also have a thicker outline to hopefully help make them more noticeable. Please tell me how you feel about the new colours.</li>
            <li>Added a new button that will allow you to toggle on/off the edit tags, edit info, edit image, and edit url buttons that appear on the tiles. The share tile button will still appear regardless.</li>
            <li>Forgot to include .cur and .jps and .jfif as supported file formats in 1.7 as I had originally indicated. They will now show as supported file types.</li>
        </ul>
        <h2>Update 1.7.1</h2>
        <ul>
            <li>Stated that the error where edit image url option was fixed in 1.7, apparently not. It should be fixed now though.</li>
        </ul>
        <h2>Update 1.7</h2>
        <ul>
            <li>Removed old depreciated functions that were replaced by newer functions (ones that used the prompt() system instead of the newer popup designs)</li>
            <li>Removed const values that were without usage: imageMethodPopup, popupContent, and deviceUploadBtn, and a duplicate urlUploadBtn</li>
            <li>When curating a tile, .jxl and .avif should now appear as available file formats when choosing to upload a local image (instead of having to select All Files.)</li>
            <li>.cur and .jps and .jfif support has been added</li>
            <li>The browser will now remember the "Remember my choice" button between refreshes instead of resetting each refresh (note this was an intentional function of the feature, not a bug.)</li>
            <li>A new "Flush Remembered State" button has been added which will allow you to reset the remembered state, showing you the NSFW inclusion/exclusion prompt when using the select random character feature.</li>
            <li>Fixed problem where the upload method popup would disappear as soon as the user selected the local option.</li>
            <li>Fixed problem where the input information section wouldn't disappear after the user curated an image.</li>
            <li>Fixed problem where the edit Image popup wouldn't disappear when submitting URL and further fixed problem where the overlay wouldn't disappear when cancelling the prompts.</li>
            <li>Fixed problem where the edit image url option wouldn't work</li>
        </ul>
        
        <h2>Update 1.6</h2>
        <ul>
            <li>Fixed error where clicking outside the popup window would cause select random character popup to not appear afterwards until refresh</li>
            <li>A new section bellow the description blurb that allows you to read all the updates</li>
            <li>The random character popup should now be more responsive for mobile devices/small screens</li>
            <li>The width of the popup should now stay consistent regardless of how much information is included for them (previously characters with less information would have shorter info boxes, causing some things to shift around.)</li>
            <li>The new triggers for the NSFW system now apply to the merger website. You will now be prompted to remove NSFW characters if they have the new tags that indicate it as being NSFW.</li>
            <li>Updated the invalid links system for the merger website to ensure that the linked website in the url section of a tile is an actual website. It does this by checking if http: or https: is included and checks if theres any periods that would imply a TLD is included (since smth like https://test/ wont lead to a website.)</li>
            <li>Added Manual Up and Down buttons on the Reordering Website that will move the tile up or down one position</li>
            <li>Added the ability to upload images either by locally uploading an image (the previous exclusive method) or by providing a web URL.</li>
            <li>When the NSFW inclusion prompt is shown, you will be prompted to either have it remember or not remember via a checkbox. Note that on refresh the state will return to unchecked.</li>
        </ul>
       <h2>Update 1.5.1</h2>
       <ul>
          <li>Modifications to the Bookmarking website, Merge Tool and Reordering Tool to make the websites more responsive on mobile/smaller devices. Note that update 1.6 will bring further improvements to this.</li>
       </ul>
       <h2>Update 1.5</h2>
       <ul>
          <li>With the reordering tool, you can now sort between the following options</li>
          <ul>
             <li>Name Alphabetically (A -> Z) and Reverse Alphabetically (Z -> A)</li>
             <li>Age by Oldest to Youngest and Youngest to Oldest</li>
             <li>Platform Name Alphabetically and Reverse Alphabetically</li>
          </ul>
          <li>Made changes to the special outline trigger to make it appear more consistently.</li>
          <ul>
             <li>Note if you're importing tiles that would have the special outline applied, you need to refresh the page before the outlines apply</li>
          </ul>
          <li>Favourite and Special Outline now Appear on the Random Character Popout Alongside the NSFW Outline</li>
          <li>FavIcons have been added to the three pages to make it easier to see which page is what</li>
          <li>Added "NSFW", "Hentai", and "Porn" as tags that will trigger the NSFW Outline</li>
          <li>.avif and .jxl are now listed as supported files</li>
          <li>Curated a new information blurb and made it collapseable</li>
          <li>When trying to use the Random Character feature, you'll be prompted if you want to include NSFW characters</li>
          <li>When the Random Character Popup is Opened, instead of having to click the Random Character button over and over (which would now show the prompt each time) you can press a reroll button to show a new character</li>
          <li>Updated the File Upload System, Edit URL System, Edit Tag System, Edit Info System and Copy URL System from the previous prompt() system to a popup system to keep the design consistent</li>
          <li>When opening a popup, an overlay blur will now appear behind the popup. Clicking the overlay will cause the current popup to close. This should prevent the openning of multiple popups at once alongside giving users a more convient way to close the popups</li>
       </ul>
       <h2>Update 1.4 (dont ask what happened to update 1.3)</h2>
       <ul>
          <li>Blur NSFW Option Now Applies to the Random Character Feature if an 18+ character is selected</li>
          <li>Updated Styling of the Random Character Feature</li>
          <li>Edit URL and Edit Photo are now to SEPERATE buttons</li>
          <li>Edit Info Button has been added that allows you to specify information relating to the character like the characters name, age, description and which platform they're available on. This information will appear when it is selected in the random character feature.</li>
          <li>Adding ⭐ Will Indicate it as a "Favourite" and curate a special outline for it</li>
          <li>Adding the 18+ will outline the tile and popup if its selected from the random character feature</li>
          <li>Changed some colours for accessibility</li>
          <li>New Merger Tool</li>
          <ul>
             <li>Merge Two Backups Together</li>
             <li>Automatically removes duplicate characters (by their hyperlink/url)</li>
             <li>Prompt to remove NSFW characters when merging files</li>
             <li>Prompt to remove characters with "https://" as their hyperlinkl</li>
          </ul>
          <li>Reordering Tool</li>
          <ul>
             <li>Allows you to reorder tiles</li>
          </ul>
       </ul>
       <h2>Update 1.2</h2>
       <ul>
          <li>Added a new system that will blur tiles that have 18+ as a tag.</li>
          <li>Changed edit image function to request a local image instead of a URL</li>
          <li>Hover colours for buttons and tags to make it more visible if you're hovering over them</li>
          <li>Description blurb on how to use the tool</li>
          <li>Changed the name of the tab and the header to Character Bookmarking Tool</li>
       </ul>
    </div>
    <div class="controls">
       <div class="theme-toggle">
          <button id="export-btn">Export</button>
          <button id="import-btn">Import</button>
          <button id="toggleButton">Hide Tile Buttons</button>
          <button id="settings-btn">Theme Settings</button>
          <button id="random-character-btn">Select Random Character</button>
          <button id="flush-button">Reset Remembered State</button>     
          <button id="openReorderToolButton">Open Reorder Tool</button>
          <button id="openBackupMergeButton">Open Backup Merge</button>
          <select id="tag-filter-mobile">
             <option value="all">All Tags</option>
          </select>
       </div>
       <div class="controls">
          <select id="tag-filter">
             <option value="all">All Tags</option>
          </select>
       </div>
    </div>
    <!-- Popup Structure -->
    <div id="character-popup" class="popup hidden">
       <div id="popup-content">
          <img id="popup-image" src="" alt="Character Image">
          <span id="popup-close">&times;</span>
          <div class="popup-info">
             <h3 id="popup-name"></h3>
             <p id="popup-platform"></p>
             <p id="popup-age"></p>
             <p id="popup-description"></p>
             <p id="popup-tags"></p>
          </div>
          <button id="popup-button" type="button">View Profile</button>
          <button id="reroll-btn">Reroll</button>
          <button id="popup-close-btn">Close</button>
       </div>
    </div>
    <!--Tile Creation Popup-->
    <div id="tile-creation-popup">
       <div id="popup-content">
       <h3>Create New Tile</h3>
       <input type="text" id="tile-link" placeholder="Enter a link for this image">
       <input type="text" id="tile-tags" placeholder="Enter tags separated by commas">
       <input type="text" id="tile-name" placeholder="Enter character name">
       <input type="text" id="tile-platform" placeholder="Enter platform">
       <input type="text" id="tile-age" placeholder="Enter age">
       <textarea id="tile-description" placeholder="Enter description"></textarea>
       <button id="create-tile-btn">Create Tile</button>
       <button id="cancel-tile-btn">Cancel</button>
    </div>
    </div>
    <!--Edit URL Popup-->
    <div id="edit-url-popup" class="edit-popup">
    <div id="popup-content">
       <h3>Edit URL</h3>
       <input type="text" id="edit-url-input" placeholder="Enter new URL">
       <button id="save-url-btn">Save</button>
       <button id="cancel-url-btn">Cancel</button>
    </div>
    </div>
    <!--Edit Info Popup-->
    <div id="edit-info-popup" class="edit-popup">
        <div id="popup-content">
       <h3>Edit Info</h3>
       <div style="width:100%">
          <span class="input-label">Character Name:</span>
          <input type="text" id="edit-name-input" placeholder="Enter character name">
       </div>
       <div style="width:100%">
          <span class="input-label">Platform:</span>
          <input type="text" id="edit-platform-input" placeholder="Enter platform">
       </div>
       <div style="width:100%">
          <span class="input-label">Age:</span>
          <input type="text" id="edit-age-input" placeholder="Enter age">
       </div>
       <div style="width:100%">
          <span class="input-label">Description:</span>
          <textarea id="edit-description-input" placeholder="Enter description"></textarea>
       </div>
       <button id="save-info-btn">Save</button>
       <button id="cancel-info-btn">Cancel</button>
    </div>
    </div>
    <!--Edit Tags Popup-->
    <div id="edit-tags-popup" class="edit-popup">
       <h3>Edit Tags</h3>
       <input type="text" id="edit-tags-input" placeholder="Enter tags separated by commas">
       <button id="save-tags-btn">Save</button>
       <button id="cancel-tags-btn">Cancel</button>
    </div>
    <!--Share URL Popup-->
    <div id="share-url-popup">
       <h3>Share URL</h3>
       <input type="text" id="share-url-input" class="notranslate" readonly>
       <button id="copy-url-btn">Copy URL</button>
       <button id="close-share-url-btn">Close</button>
    </div>
    <!-- NSFW Inclusion Popup -->
    <div id="nsfw-inclusion-popup">
        <div id="popup-content">
        <h3>Include NSFW Characters?</h3>
        <p>Do you want to include NSFW characters in the random selection?</p>
            <button id="include-nsfw-btn">Yes, Include NSFW</button>
            <button id="exclude-nsfw-btn">No, Exclude NSFW</button>
        <label>
            <input type="checkbox" id="remember-nsfw-state-checkbox"> Remember my choice</input>
        </label>
        </div>
    </div>  
    <!-- Settings Popup -->
    <div id="settings-popup" style="overflow-y: auto;">
        <div id="popup-content">
        <h3>Theme Settings</h3>
            <button id="blur-nsfw-btn">Blur NSFW</button>
            <button id="theme-toggle-btn">Light Mode</button>
            <button id="hide-tags-button">Hide Tags</button>
            <button id="toggle-position-btn">Move Add Image to Beginning</button>
            <select id="colorSelector">
                <option value="original">Original</option>
                <option value="colour1">Deuteranopia</option>
                <option value="colour2">Protanopia</option>
                <option value="colour3">Tritanopia</option> 
            </select>   
            <select id="tileSize">
                <option value="small">Small Tiles</option>
                <option value="medium" selected>Medium Tiles</option>
                <option value="large">Large Tiles</option>
            </select>
            <button id="exportButton">Export Theme Settings</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" />
            <button id="importButton">Import Theme Settings</button>
            <button id="settings-close">Close</button>
        </div>
    </div>    

    <div id="image-popup" class="popup hidden">
       <div id="popup-content">
          <h3>Select Image Source</h3>
          <button id="local-upload-btn">Upload from Device</button>
          <button id="url-upload-btn">Provide Image URL</button>
          <button id="url-popup-close">Close</button>
       </div>
    </div>
    <div id="image-source-popup" class="popup hidden">
        <div id="popup-content">
        <h2>Select Image Source</h2>
        <button id="local-image-btn">Upload from Device</button>
        <button id="url-image-btn">Provide URL</button>
        <button id="urlURL-popup-close">Close</button>
        </div>
    </div>
    
    <!-- Add this HTML for the URL input popup -->
    <div id="url-input-popup" class="popup hidden">
        <h2>Enter Image URL</h2>
        <input type="text" id="image-url-input" placeholder="Enter image URL">
        <button id="submit-url-btn">Submit</button>
        <button id="url-popup-close-url1">Close</button>
    </div>
    <div id="url-popup" class="popup hidden">
        <div id="popup-content">
           <h3>Enter Image URL</h3>
           <input type="text" id="image-url-input1" placeholder="Paste image URL here" />
           <button id="submit-url-btn1">Submit</button>
           <button id="url-popup-close-url">Close</button>
        </div>
     </div>
    <!-- Image Selection Prompt -->
    <div id="image-method-popup" class="popup hidden">
       <div class="popup-content">
          <h2>Select Image Source</h2>
          <button id="local-image-btn">Upload Local Image</button>
          <button id="url-image-btn">Use Image URL</button>
          <button id="cancel-image-selection">Cancel</button>
       </div>
    </div>
    <div id="undo-delete-popup">
  <p>Tile deleted. <span id="undo-timer">30</span>s</p>
  <div>
    <button id="undo-delete-btn">Undo</button>
    <button id="dismiss-undo">✕</button>
  </div>
</div>
    <!-- Add the file input for uploading images -->
    <input type="file" id="file-input" accept="image/*,.avif,.jxl,.cur,.jps,.jfif" class="hidden">
    <div class="image-grid" id="image-grid">
       <div class="image-item add-image" id="add-image">
          +
       </div>
    </div>
    <input type="file" id="file-input" accept="image/*,.avif,.jxl,.cur,.jps,.jfif">
    <input type="file" id="import-file-input" accept="application/json">
    <div id="popup-overlay" class="popup-overlay"></div>
    
    <script>
const popupOverlay = document.getElementById("popup-overlay");
const imageGrid = document.getElementById('image-grid');
const addImageButton = document.getElementById('add-image');
const fileInput = document.getElementById('file-input');
const tagFilter = document.getElementById('tag-filter') ;
const tagFilterMobile = document.getElementById('tag-filter-mobile');
const exportBtn = document.getElementById('export-btn');
const importBtn = document.getElementById('import-btn');
const importFileInput = document.getElementById('import-file-input');
const blurNSFWBtn = document.getElementById('blur-nsfw-btn');
const imageUploadChoicePopup = document.getElementById('image-upload-choice-popup');
const urlUploadBtn = document.getElementById('url-upload-btn');
const addImageTile = document.getElementById('add-image');
const togglePositionBtn = document.getElementById('toggle-position-btn');
const undoPopup = document.getElementById('undo-delete-popup');
const undoButton = document.getElementById('undo-delete-btn');
const dismissButton = document.getElementById('dismiss-undo');
const timerSpan = document.getElementById('undo-timer');
const tileSizeSelector = document.getElementById('tileSize');
const starTags = ['⭐', '🌟', '✨', '🌠', '💫', '🤩', '❇️', '✴️', '✳️'];
const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; 
const hideTagsButton = document.getElementById("hide-tags-button");
const tags = document.querySelectorAll(".tag");

let tagsVisible = true;

// Load the visibility state from local storage on page load
window.addEventListener('load', function() {
    const storedVisibility = localStorage.getItem('tagsVisible');
    if (storedVisibility !== null) {
        tagsVisible = storedVisibility === 'true'; // Convert string to boolean
    }
    updateTagVisibility(tagsVisible);
});

hideTagsButton.addEventListener('click', function() {
    tagsVisible = !tagsVisible; // Toggle visibility
    updateTagVisibility(tagsVisible);
    
    // Save the visibility state in local storage
    localStorage.setItem('tagsVisible', tagsVisible);
});

function updateTagVisibility(visible) {
    const tags = document.querySelectorAll('.tag');
    tags.forEach(tag => {
        tag.style.display = visible ? 'block' : 'none'; // Show or hide the tag
    });

    // Change the button text based on the tags' state
    hideTagsButton.textContent = visible ? 'Hide Tags' : 'Show Tags';
}

// Initialize tag visibility based on the stored state
updateTagVisibility(tagsVisible);


let tiles = [];
let allTags = new Set();
let isBlurred = JSON.parse(localStorage.getItem('isBlurred')) || false; // Load blur status from localStorage
let rememberNSFWChoice = JSON.parse(localStorage.getItem('rememberNSFWChoice')) || false;
let includeNSFW = JSON.parse(localStorage.getItem('includeNSFW')) || false;
let deletedTile = null;
let undoTimer = null;

let isAtEnd =  true;  // Initially, the add-image tile is at the end



document.getElementById('openReorderToolButton').addEventListener('click', function() {
        window.open('https://thatoneunoriginal.github.io/reorder%20tool.html', '_blank');
    });

    document.getElementById('openBackupMergeButton').addEventListener('click', function() {
        window.open('https://thatoneunoriginal.github.io/backup%20merge.html', '_blank');
    });

document.getElementById('exportButton').addEventListener('click', () => {
    // Retrieve values from local storage
    const settings = {
        isBlurred: localStorage.getItem('isBlurred'),
        theme: localStorage.getItem('theme'),
        addImagePosition: localStorage.getItem('addImagePosition'),
        selectedColorOption: localStorage.getItem('selectedColorOption'),
        tileSize: localStorage.getItem('tileSize')
    };

    // Convert settings to a JSON string
    const settingsJSON = JSON.stringify(settings, null, 2);

    // Create a Blob object to facilitate download
    const blob = new Blob([settingsJSON], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    // Create a temporary link element for downloading
    const a = document.createElement('a');
    a.href = url;
    a.download = 'settings.json'; // Filename for the downloaded file
    document.body.appendChild(a);
    a.click(); // Trigger the download
    document.body.removeChild(a); // Clean up

    // Release the blob URL
    URL.revokeObjectURL(url);
});

document.getElementById('importButton').addEventListener('click', () => {
    const fileInput = document.getElementById('importFile');
    fileInput.click(); // Programmatically click the file input

    // Add an event listener for when a file is selected
    fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];

        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const settings = JSON.parse(event.target.result);
                    
                    // Apply settings to local storage
                    localStorage.setItem('isBlurred', settings.isBlurred);
                    localStorage.setItem('theme', settings.theme);
                    localStorage.setItem('addImagePosition', settings.addImagePosition);
                    localStorage.setItem('selectedColorOption', settings.selectedColorOption);
                    localStorage.setItem('tileSize', settings.tileSize);
                    
                    alert('Settings imported successfully! Refresh the page to have the changes apply');
                } catch (error) {
                    alert('Failed to import settings: ' + error.message);
                }
            };

            reader.readAsText(file);
        } else {
            alert('No file selected.');
        }
    }, { once: true }); // Ensure the listener is only added once
});


// Function to toggle the position of the add-image tile
function toggleAddImagePosition() {
    if (isAtEnd) {
        // Move to the beginning (before the first non-add-image tile, if any)
        imageGrid.insertBefore(addImageTile, imageGrid.firstElementChild);
        togglePositionBtn.textContent = 'Move Add Image to End';
        localStorage.setItem('addImagePosition', 'beginning');
    } else {
        // Move to the end
        imageGrid.appendChild(addImageTile);
        togglePositionBtn.textContent = 'Move Add Image to Beginning';
        localStorage.setItem('addImagePosition', 'end');
    }
    isAtEnd = !isAtEnd;  // Toggle the state
}

// Function to apply the saved position on page load
function applySavedPosition() {
    const savedPosition = localStorage.getItem('addImagePosition');
    if (savedPosition === 'beginning') {
        // Move to the beginning (before the first tile in the grid)
        imageGrid.insertBefore(addImageTile, imageGrid.firstElementChild);
        togglePositionBtn.textContent = 'Move Add Image to End';
        isAtEnd = false;
    } else {
        // Move to the end by default
        imageGrid.appendChild(addImageTile);
        togglePositionBtn.textContent = 'Move Add Image to Beginning';
        isAtEnd = true;
    }
}

// Apply the saved position when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', applySavedPosition);

// Add event listener to the button
togglePositionBtn.addEventListener('click', toggleAddImagePosition);


// Function to set the tile size
function setTileSize(size) {
    let sizeValue;
    switch (size) {
        case 'small':
            sizeValue = '150px';
            break;
        case 'medium':
            sizeValue = '200px';
            break;
        case 'large':
            sizeValue = '250px';
            break;
        default:
            sizeValue = '200px'; // default to medium if nothing is found
    }
    imageGrid.style.setProperty('--tile-size', sizeValue);
}

// Load the saved tile size from local storage on page load
window.addEventListener('DOMContentLoaded', function() {
    const savedSize = localStorage.getItem('tileSize') || 'medium'; // Default to 'medium' if no value is found
    tileSizeSelector.value = savedSize; // Set the dropdown to the saved value
    setTileSize(savedSize); // Apply the saved size to the grid
});

// Save the tile size to local storage when the user changes it
tileSizeSelector.addEventListener('change', function() {
    const selectedSize = this.value;
    localStorage.setItem('tileSize', selectedSize); // Save the selected size
    setTileSize(selectedSize); // Apply the new size to the grid
});

function showUndoPopup() {
  undoPopup.classList.add('show');
  let secondsLeft = 30;
  timerSpan.textContent = secondsLeft;

  undoTimer = setInterval(() => {
    secondsLeft--;
    timerSpan.textContent = secondsLeft;

    if (secondsLeft <= 0) {
      hideUndoPopup();
    }
  }, 1000);
}

function hideUndoPopup() {
  clearInterval(undoTimer);
  undoPopup.classList.remove('show');
  deletedTile = null;
}

// Save the selected color option in localStorage
document.getElementById('colorSelector').addEventListener('change', function() {
    const selectedColorOption = this.value; 
    localStorage.setItem('selectedColorOption', selectedColorOption); // Save to local storage

    const nsfwTiles = document.querySelectorAll('.nsfw-outline, .highlight-nsfw');
    const specialTiles = document.querySelectorAll('.special-outline');
    const starTiles = document.querySelectorAll('.star-outline, .highlight-favourite');

    // Select all specified buttons
    const buttons = document.querySelectorAll(
        '.theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #import-btn, #tile-size, #colorSelector, #popup-button, #reroll-btn, ' +
        '#local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, ' +
        '#url-popup-close-url1, #popup-close, .collapsible, .edit-popup button, #submit-url-btn, #submit-url-btn1, #share-url-popup button, ' +
        '#nsfw-inclusion-popup button, #image-upload-choice-popup button, #settings-popup button, #tileSize, #undo-delete-popup button, .highlight, #popup-close-btn'
    );

    // Define colors based on the selected option
    const nsfwColors = [
        'var(--nsfw-color-1)', 
        'var(--nsfw-color-2)', 
        'var(--nsfw-color-3)', 
        'var(--nsfw-color-4)'  
    ];

    const specialColors = [
        'var(--special-outline-color-1)', 
        'var(--special-outline-color-2)', 
        'var(--special-outline-color-3)', 
        'var(--special-outline-color-4)'  
    ];

    const starColors = [
        'var(--star-outline-color-1)', 
        'var(--star-outline-color-2)', 
        'var(--star-outline-color-3)', 
        'var(--star-outline-color-4)'  
    ];

    const buttonColors = [
        'var(--button-bg-1)', 
        'var(--button-bg-2)', 
        'var(--button-bg-3)', 
        'var(--button-bg-4)'  
    ];

    const buttonHoverColors = [
        'var(--button-bg-hover-1)', 
        'var(--button-bg-hover-2)', 
        'var(--button-bg-hover-3)', 
        'var(--button-bg-hover-4)'  
    ];

    const selectedIndex = this.value === 'original' ? 0 : 
                          (this.value === 'colour1' ? 1 : 
                          (this.value === 'colour2' ? 2 : 3));

    // Get selected colors
    const selectedNsfwColor = nsfwColors[selectedIndex];
    const selectedSpecialColor = specialColors[selectedIndex];
    const selectedStarColor = starColors[selectedIndex];
    const selectedButtonColor = buttonColors[selectedIndex];
    const selectedButtonHoverColor = buttonHoverColors[selectedIndex];

    // Apply colors
    specialTiles.forEach(tile => tile.style.borderColor = selectedSpecialColor);
    nsfwTiles.forEach(tile => {
        if (!tile.classList.contains('special-outline')) {
            tile.style.borderColor = selectedNsfwColor;
        }
    });
    starTiles.forEach(tile => {
        if (!tile.classList.contains('special-outline')) {
            tile.style.borderColor = selectedStarColor;
        }
    });

    // Apply button background color
    buttons.forEach(button => {
        button.style.backgroundColor = selectedButtonColor;

        // Set up hover effect through CSS for specified selectors
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = selectedButtonHoverColor;
        });
        button.addEventListener('mouseleave', () => {
            button.style.backgroundColor = selectedButtonColor;
        });
    });
});

// Load the selected color option on page load
function loadSelectedColorOption() {
    const savedOption = localStorage.getItem('selectedColorOption');
    if (savedOption) {
        const colorSelector = document.getElementById('colorSelector');
        colorSelector.value = savedOption; // Set the dropdown to the saved value
        // Trigger change event to apply the colors
        const event = new Event('change');
        colorSelector.dispatchEvent(event);
    }
}

// Call this function when the page loads
window.onload = loadSelectedColorOption;
document.addEventListener('DOMContentLoaded', loadSelectedColorOption);

document.getElementById('toggleButton').addEventListener('click', function() {
    // Get all elements with class 'edit-image-btn', 'edit-url-btn', etc.
    const editButtons = document.querySelectorAll('.edit-image-btn');
    const editURL = document.querySelectorAll('.edit-url-btn');
    const editTags = document.querySelectorAll('.edit-tags-btn');
    const editInfo = document.querySelectorAll('.edit-info-btn');
    const editDelete = document.querySelectorAll('.delete-btn');
    
    // Toggle the display property for each button
    const toggleDisplay = (buttons) => {
        buttons.forEach(button => {
            button.style.display = button.style.display === 'none' ? 'flex' : 'none';
        });
    };

    toggleDisplay(editButtons);
    toggleDisplay(editURL);
    toggleDisplay(editTags);
    toggleDisplay(editInfo);
    toggleDisplay(editDelete);

    // Check the current state of the button and save it to localStorage
    const isHidden = editButtons[0].style.display === 'none';
    localStorage.setItem('buttonsHidden', isHidden);

    // Change the text of the toggle button
    this.textContent = isHidden ? 'Show Tile Buttons' : 'Hide Tile Buttons';
});

// On page load, apply the saved toggle state from localStorage
document.addEventListener('DOMContentLoaded', function() {
    const editButtons = document.querySelectorAll('.edit-image-btn');
    const editURL = document.querySelectorAll('.edit-url-btn');
    const editTags = document.querySelectorAll('.edit-tags-btn');
    const editInfo = document.querySelectorAll('.edit-info-btn');
    const editDelete = document.querySelectorAll('.delete-btn');
    const toggleButton = document.getElementById('toggleButton');

    // Get the saved state from localStorage
    const isHidden = localStorage.getItem('buttonsHidden') === 'true';

    // Function to apply the display state
    const setDisplay = (buttons, display) => {
        buttons.forEach(button => {
            button.style.display = display;
        });
    };

    // Apply the saved state to the buttons
    setDisplay(editButtons, isHidden ? 'none' : 'flex');
    setDisplay(editURL, isHidden ? 'none' : 'flex');
    setDisplay(editTags, isHidden ? 'none' : 'flex');
    setDisplay(editInfo, isHidden ? 'none' : 'flex');
    setDisplay(editDelete, isHidden ? 'none' : 'flex');

    // Set the toggle button text based on the state
    toggleButton.textContent = isHidden ? 'Show Tile Buttons' : 'Hide Tile Buttons';
});

tagFilterMobile.addEventListener('change', filterTilesMobile);

function updateTagFilterMobile() {
    const currentFilter = tagFilterMobile.value;
    tagFilterMobile.innerHTML = '<option value="all">All Tags</option>';

    allTags.forEach(tag => {
        // Add star-related tags as "⭐" if any exist
        if (starTags.includes(tag)) {
            if (!Array.from(tagFilterMobile.options).some(option => option.value === '⭐')) {
                const option = document.createElement('option');
                option.value = '⭐';
                option.textContent = '⭐';
                tagFilterMobile.appendChild(option);
            }
        } 
        // Add NSFW and 18+ tags separately
        else if (nsfwTags.includes(tag)) {
            if (!Array.from(tagFilterMobile.options).some(option => option.value === tag)) {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilterMobile.appendChild(option);
            }
        } else {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            tagFilterMobile.appendChild(option);
        }
    });

    tagFilterMobile.value = currentFilter;
    filterTilesMobile();
}

function filterTilesMobile() {
    const selectedTag = tagFilterMobile.value;
    tiles.forEach((tile, index) => {
        const tileElement = imageGrid.children[index];

        // Check if the tile matches the selected tag or its equivalent
        const isMatchingTag = selectedTag === 'all' ||
            tile.tags.includes(selectedTag) ||
            tile.platform === selectedTag ||
            tile.age === selectedTag;

        // Treat ⭐ as matching all star-related tags
        const isStarEquivalent = (selectedTag === '⭐' && tile.tags.some(tag => starTags.includes(tag)));

        // Treat 18+ as matching both "NSFW" and "18+"
        const isNSFWEquivalent = (selectedTag === 'NSFW' && tile.tags.some(tag => nsfwTags.includes(tag)));

        if (isMatchingTag || isStarEquivalent || isNSFWEquivalent) {
            tileElement.style.display = '';
        } else {
            tileElement.style.display = 'none';
        }
    });
}

addImageButton.addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'block';
    document.getElementById('popup-overlay').style.display = 'block';
});

// Add event listeners for the new buttons
document.getElementById('local-image-btn').addEventListener('click', () => {
    fileInput.click();
});

document.getElementById('url-image-btn').addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'none';
    document.getElementById('url-input-popup').style.display = 'block';
});

document.getElementById('submit-url-btn').addEventListener('click', () => {
    const imageUrl = document.getElementById('image-url-input').value.trim();
    if (imageUrl) {
        document.getElementById('url-input-popup').style.display = 'none';
        document.getElementById('popup-overlay').style.display = 'none';
        showTileCreationPopup(imageUrl);
    }
});

document.getElementById('create-tile-btn').addEventListener('click', () => {
    document.getElementById('popup-overlay').style.display = 'none';
});

document.getElementById('url-popup-close-url1').addEventListener('click', () => {
    document.getElementById('url-input-popup').style.display = 'none';
    document.getElementById('popup-overlay').style.display = 'none';
});

document.getElementById('urlURL-popup-close').addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'none';
    document.getElementById('popup-overlay').style.display = 'none';
});
document.getElementById('settings-close').addEventListener('click', () => {
    document.getElementById('popup-overlay').style.display = 'none';
    document.getElementById('settings-popup').style.display = 'none';
});
document.getElementById('popup-overlay').addEventListener('click', () => {
   document.getElementById('image-source-popup').style.display = 'none';
   document.getElementById('url-input-popup').style.display = 'none';
   document.getElementById('popup-overlay').style.display = 'none';
   document.getElementById('popup-overlay').style.display = 'none';
   document.getElementById('settings-popup').style.display = 'none';
   document.getElementById('edit-url-popup').style.display = 'none';
   document.getElementById('tile-creation-popup').style.display = 'none';
   document.getElementById('character-popup').style.display = 'none';
   document.getElementById('edit-info-popup').style.display = 'none';
   document.getElementById('edit-tags-popup').style.display = 'none';
   document.getElementById('share-url-popup').style.display = 'none';
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
});

function showEditUrlPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-url-popup');
   const urlInput = document.getElementById('edit-url-input');
   urlInput.value = tileData.link;
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';
   document.getElementById('save-url-btn').onclick = () => {
      tileData.link = urlInput.value;
      tileElement.querySelector('a').href = tileData.link;
      saveTiles();
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };

   document.getElementById('cancel-url-btn').onclick = () => {
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}

function filterTilesByPlatform() {
   const selectedPlatform = document.getElementById('platform-filter').value;
   const tiles = document.querySelectorAll('.tile'); // Assuming .tile is the class for each tile

   tiles.forEach(tile => {
      const platform = tile.getAttribute('data-platform'); // Assuming platform info is stored in a data attribute

      if (selectedPlatform === 'all' || platform === selectedPlatform) {
         tile.style.display = 'block'; // Show the tile
      } else {
         tile.style.display = 'none'; // Hide the tile
      }
   });
}


function showEditInfoPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-info-popup');
   document.getElementById('edit-name-input').value = tileData.name || '';
   document.getElementById('edit-platform-input').value = tileData.platform || '';
   document.getElementById('edit-age-input').value = tileData.age || '';
   document.getElementById('edit-description-input').value = tileData.description || '';
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';


   document.getElementById('save-info-btn').onclick = () => {
      tileData.name = document.getElementById('edit-name-input').value;
      tileData.platform = document.getElementById('edit-platform-input').value;
      tileData.age = document.getElementById('edit-age-input').value;
      tileData.description = document.getElementById('edit-description-input').value;
      saveTiles();
      updateTagFilter();
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';

   };

   document.getElementById('cancel-info-btn').onclick = () => {
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';

   };
}

// Function to show the edit tags popup
function showEditTagsPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-tags-popup');
   document.getElementById('edit-tags-input').value = tileData.tags.join(', ');
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('save-tags-btn').onclick = () => {
      const newTags = document.getElementById('edit-tags-input').value.split(',')
         .map(tag => tag.trim()) // Trim whitespace from each tag
         .filter(tag => tag) // Remove empty tags
         .filter((tag, index, self) => self.indexOf(tag) === index); // Remove duplicates


      tileData.tags = newTags;
      updateTileTags(tileElement, tileData.tags);
      updateTileOutline(tileElement, tileData.tags);
      saveTiles();
      updateTagFilter();
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };

   document.getElementById('cancel-tags-btn').onclick = () => {
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}



// Theme management
function setTheme(theme) {
   document.body.className = theme;
   localStorage.setItem('theme', theme);
}
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
   coll[i].addEventListener("click", function () {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.maxHeight) {
         content.style.maxHeight = null;
      } else {
         content.style.maxHeight = content.scrollHeight + "px";
      }
   });
}

function applyStoredTheme() {
   const storedTheme = localStorage.getItem('theme') || '';
   setTheme(storedTheme);
}

const themeToggleBtn = document.getElementById('theme-toggle-btn');

const themes = ['', 'dark-mode', 'amoled-mode'];
let currentThemeIndex = 0;  // Index to track the current theme

// Function to apply the theme
function setTheme(theme) {
    // Apply the theme to the body or wherever it’s needed
    document.body.className = theme;

    // Save the theme in local storage
    localStorage.setItem('theme', theme);

    // Update the button text based on the theme
    if (theme === '') {
        themeToggleBtn.textContent = 'Light Mode';
    } else if (theme === 'dark-mode') {
        themeToggleBtn.textContent = 'Dark Mode';
    } else if (theme === 'amoled-mode') {
        themeToggleBtn.textContent = 'Amoled Mode';
    }
}

// Function to cycle through the themes
function toggleTheme() {
    // Move to the next theme
    currentThemeIndex = (currentThemeIndex + 1) % themes.length;
    setTheme(themes[currentThemeIndex]);
}

// Function to apply the stored theme on page load
function applyStoredTheme() {
    const storedTheme = localStorage.getItem('theme') || '';
    currentThemeIndex = themes.indexOf(storedTheme);
    setTheme(storedTheme);
}

// Add event listener to the button
themeToggleBtn.addEventListener('click', toggleTheme);

// Apply theme on load
applyStoredTheme();

// Load saved tiles
function loadSavedTiles() {
   tiles = JSON.parse(localStorage.getItem('imageTiles')) || [];
   tiles.forEach(tile => {
      createImageTile(tile);
      tile.tags.forEach(tag => allTags.add(tag));
   });
   updateTagFilter();
}

// Save tiles
function saveTiles() {
   localStorage.setItem('imageTiles', JSON.stringify(tiles));
}

function createImageTile(tileData) {
   const newImageItem = document.createElement('div');
   newImageItem.className = 'image-item';

   const hasNSFW = tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn') || tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞');
   const hasStar = tileData.tags.includes('⭐') || tileData.tags.includes('✨') || tileData.tags.includes('🌠') || tileData.tags.includes('🌟') ||
                   tileData.tags.includes('💫') || tileData.tags.includes('🤩') || tileData.tags.includes('❇️') || tileData.tags.includes('✴️') ||
                   tileData.tags.includes('✳️') || tileData.tags.includes('🔥') || tileData.tags.includes('💎');

   if (hasNSFW) {
      newImageItem.classList.add('nsfw-outline');
   }
   if (hasStar) {
      newImageItem.classList.add('star-outline');
   }
   if (hasNSFW && hasStar) {
      newImageItem.classList.add('special-outline');
   }

   newImageItem.innerHTML = `
                <a href="${tileData.link}" target="_blank" class="image-container">
                    <img src="${tileData.imageData}" alt="User uploaded image">
                </a>
                <div class="tile-buttons">
                    <button class="edit-image-btn" title="Edit Image">🖼️</button>
                    <button class="edit-url-btn" title="Edit URL">🔗</button>
                    <button class="edit-tags-btn" title="Edit Tags">🏷️</button>
                    <button class="edit-info-btn" title="Edit Info">ℹ️</button>
                    <button class="share-btn" title="Share">📤</button>
                    <button class="delete-btn" title="Delete">×</button>
                </div>
                <div class="tags">
                    ${tileData.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
            `;

   // Find the last tile that's not the add-image button
   const tiles = Array.from(imageGrid.children);
   const lastTile = tiles.filter(tile => !tile.classList.contains('add-image')).pop();

   // Insert the new tile after the last existing tile, or at the beginning if there are no tiles
   if (lastTile) {
      imageGrid.insertBefore(newImageItem, lastTile.nextSibling);
   } else {
      imageGrid.insertBefore(newImageItem, imageGrid.firstChild);
   }

   // Add edit image functionality
   newImageItem.querySelector('.edit-image-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      editImage(tileData, newImageItem);
   });

   // Add edit tags functionality
   newImageItem.querySelector('.edit-tags-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      showEditTagsPopup(tileData, newImageItem);
   });

   // Add share functionality
   newImageItem.querySelector('.share-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      shareTile(tileData);
   });

   // Add delete functionality
   newImageItem.querySelector('.delete-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteTile(tileData, newImageItem);
   });

   // Add edit URL functionality
   newImageItem.querySelector('.edit-url-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      showEditUrlPopup(tileData, newImageItem);
   });
   // Add edit info functionality
   newImageItem.querySelector('.edit-info-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      showEditInfoPopup(tileData, newImageItem);
   });
}



function updateTileOutline(tileElement, tags) {
   tileElement.classList.remove('nsfw-outline', 'star-outline', 'special-outline');
   
   const hasNSFW = tags.includes('18+') || tags.includes('NSFW') || tags.includes('Porn') || tags.includes('Hentai') || tags.includes('Yaoi') || tags.includes('🔞');
   const hasStar = tags.includes('⭐') || tags.includes('✨') || tags.includes('🌠') || tags.includes('🌟') ||
                   tags.includes('💫') || tags.includes('🤩') || tags.includes('❇️') || tags.includes('✴️') ||
                   tags.includes('✳️') || tags.includes('🔥') || tags.includes('💎');

   if (hasNSFW && hasStar) {
      tileElement.classList.add('special-outline');
   } else if (hasNSFW) {
      tileElement.classList.add('nsfw-outline');
   } else if (hasStar) {
      tileElement.classList.add('star-outline');
   }
}


function stripUrlParams(url) {
   try {
      const urlObj = new URL(url); // Create a URL object
      return urlObj.origin + urlObj.pathname; // Return the base URL without query parameters
   } catch (error) {
      console.error('Invalid URL:', error);
      return url; // Return the original URL if invalid
   }
}
// Edit image
function editImage(tileData, tileElement) {
    console.log('TEST');
        const popup = document.getElementById('image-popup');
        const localUploadBtn = document.getElementById('local-upload-btn');
        const popupClose = document.getElementById('popup-close');
        const urlPopup = document.getElementById('url-popup');
        const urlInput = document.getElementById('image-url-input');
        const urlInput1 = document.getElementById('image-url-input1');
        const submitUrlBtn = document.getElementById('submit-url-btn');
        const urlPopupClose = document.getElementById('url-popup-close');
        const imageUploadClose = document.getElementById('urlURL-popup-close');
        const urlURLPopupClose = document.getElementById('url-popup-close-url');

        // Show the main popup
        popup.classList.remove('hidden');
        document.getElementById('image-popup').style.display = 'block';
        document.getElementById('popup-overlay').style.display = 'block';

        // Close main popup functionality
        popupClose.onclick = () => {
            popup.classList.add('hidden');
            document.getElementById('popup-overlay').style.display = 'none';
        };

        localUploadBtn.onclick = () => {
            console.log('TEST2');
            const imageUploadInput = document.createElement('input');
            imageUploadInput.type = 'file';
            imageUploadInput.accept = 'image/*,.avif,.jxl,.cur,.jps,.jfif';

            imageUploadInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();

                    reader.onload = function (e) {
                        const newImageData = e.target.result;
                        tileData.imageData = newImageData;
                        tileElement.querySelector('img').src = newImageData;

                        saveTiles();
                    };

                    reader.readAsDataURL(file);
                }
                popup.classList.add('hidden');
                document.getElementById('popup-overlay').style.display = 'none';
                document.getElementById('image-popup').style.display = 'none';
            });

            imageUploadInput.click();
        };

        urlUploadBtn.onclick = () => {

            console.log('TEST3');
            // Hide the main popup and show the URL input popup
            document.getElementById('image-popup').style.display = 'none';
            document.getElementById('url-popup').style.display = 'block';
            popup.classList.add('hidden');
            urlPopup.classList.remove('hidden');
        };

        // Submit URL functionality
        document.getElementById('submit-url-btn1').onclick = () => {
            console.log('TEST4');
            let imageUrl = urlInput1.value.trim();

            if (imageUrl) {
                imageUrl = stripUrlParams(imageUrl); // Strip query parameters from URL
                tileData.imageData = imageUrl;
                tileElement.querySelector('img').src = imageUrl;
                console.log('TEST');
                saveTiles();
            }
            document.getElementById('image-popup').style.display = 'none';
            document.getElementById('url-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
            urlPopup.classList.add('hidden');
        };

        // Close URL popup functionality
        urlPopupClose.onclick = () => {
            urlPopup.classList.add('hidden');
            document.getElementById('image-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        };

        urlURLPopupClose.onclick = () => {
            document.getElementById('url-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        };
    }

document.getElementById('popup-overlay').onclick = () => {
   document.getElementById('url-popup').style.display = 'none';
   document.getElementById('image-popup').style.display = 'none';
};

function createTileData(imageData, link, tags, name, platform, age, description) {
   return {
      imageData,
      link,
      tags,
      name,
      platform,
      age,
      description
   };
}

// Share tile
function shareTile(tileData) {
   const popup = document.getElementById('share-url-popup');
   const urlInput = document.getElementById('share-url-input');
   urlInput.value = tileData.link;
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('copy-url-btn').onclick = () => {
      urlInput.select();
      document.execCommand('copy');
      console.log('URL copied to clipboard!');
   };

   document.getElementById('close-share-url-btn').onclick = () => {
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}

// Delete tile
function deleteTile(tileData, tileElement) {
  // Find the index of the tile in the tiles array
  const tileIndex = tiles.indexOf(tileData);

  // Check if the add-image tile is at the beginning
  const addImagePosition = localStorage.getItem('addImagePosition');
  const adjustedIndex = (addImagePosition === 'beginning' && tileIndex >= 1) ? tileIndex + 1 : tileIndex;

  // Store the deleted tile data, element, and its adjusted index
  deletedTile = { data: tileData, element: tileElement, index: adjustedIndex };

  // Remove the tile from the grid and update the tiles array
  tiles.splice(tileIndex, 1);
  imageGrid.removeChild(tileElement);
  saveTiles();
  updateTagFilter();

  // Show the undo popup
  showUndoPopup();
}

function undoDelete() {
  if (deletedTile) {
    // Adjust the index when adding the tile back
    const addImagePosition = localStorage.getItem('addImagePosition');
    const adjustedIndex = (addImagePosition === 'beginning') ? deletedTile.index + 1 : deletedTile.index;

    // Add the tile back to the tiles array at its original index
    tiles.splice(adjustedIndex, 0, deletedTile.data);

    // Find the correct position to insert the tile in the grid
    const nextSibling = imageGrid.children[adjustedIndex] || null;
    imageGrid.insertBefore(deletedTile.element, nextSibling);

    saveTiles();
    updateTagFilter();

    // Hide the undo popup
    hideUndoPopup();
  }
}

undoButton.addEventListener('click', undoDelete);
dismissButton.addEventListener('click', hideUndoPopup);


// Update tile tags
function updateTileTags(tileElement, tags) {
   const tagsContainer = tileElement.querySelector('.tags');
   tagsContainer.innerHTML = tags.map(tag => `<span class="tag">${tag}</span>`).join('');
   updateAllTags();
}

// Update all tags
function updateAllTags() {
   allTags.clear();
   tiles.forEach(tile => {
      tile.tags.forEach(tag => allTags.add(tag));
      if (tile.platform) allTags.add(tile.platform);
      if (tile.age) allTags.add(tile.age);
   });
   updateTagFilter();
}

function updateTagFilter() {
    const currentFilter = tagFilter.value;
    tagFilter.innerHTML = '<option value="all">All Tags</option>';
    
    allTags.forEach(tag => {
        // Add only the ⭐ option if any star-related tags exist
        if (starTags.includes(tag)) {
            if (!Array.from(tagFilter.options).some(option => option.value === '⭐')) {
                const option = document.createElement('option');
                option.value = '⭐';
                option.textContent = '⭐';
                tagFilter.appendChild(option);
            }
        } 
        // Add NSFW and 18+ tags separately
        else if (nsfwTags.includes(tag)) {
            if (!Array.from(tagFilter.options).some(option => option.value === tag)) {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            }
        } else {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            tagFilter.appendChild(option);
        }
    });
    
    tagFilter.value = currentFilter;
    filterTiles();

    // Update mobile tag filter as well
    updateTagFilterMobile();
}


// Filter tiles based on selected tag for desktop
function filterTiles() {
    const selectedTag = tagFilter.value;
    tiles.forEach((tile, index) => {
        const tileElement = imageGrid.children[index];
        
        // Check if the tile matches the selected tag or its equivalent
        const isMatchingTag = selectedTag === 'all' ||
            tile.tags.includes(selectedTag) ||
            tile.platform === selectedTag ||
            tile.age === selectedTag;

        // Treat ⭐ as matching all star-related tags
        const isStarEquivalent = (selectedTag === '⭐' && tile.tags.some(tag => starTags.includes(tag)));

        // Treat 18+ as matching both "NSFW" and "18+"
        const isNSFWEquivalent = (selectedTag === 'NSFW' && tile.tags.some(tag => nsfwTags.includes(tag)));

        if (isMatchingTag || isStarEquivalent || isNSFWEquivalent) {
            tileElement.style.display = '';
        } else {
            tileElement.style.display = 'none';
        }
    });
}

// Handle file selection
fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const imageData = e.target.result;
                showTileCreationPopup(imageData);
            };
            reader.readAsDataURL(file);
        }
        document.getElementById('popup-overlay').style.display = 'none';
    });

function clearTileCreationPopupInputs() {
    document.getElementById('tile-link').value = '';
    document.getElementById('tile-tags').value = '';
    document.getElementById('tile-name').value = '';
    document.getElementById('tile-platform').value = '';
    document.getElementById('tile-age').value = '';
    document.getElementById('tile-description').value = '';
}


function showTileCreationPopup(imageSource) {
    document.getElementById('image-source-popup').style.display = 'none';
    const popup = document.getElementById('tile-creation-popup');
    popup.style.display = 'flex';
    document.getElementById('popup-overlay').style.display = 'block';

    const createBtn = document.getElementById('create-tile-btn');
    const cancelBtn = document.getElementById('cancel-tile-btn');

    createBtn.onclick = () => {
        const link = document.getElementById('tile-link').value;
        const tags = document.getElementById('tile-tags').value.split(',')
            .map(tag => tag.trim()) // Trim whitespace from each tag
            .filter(tag => tag) // Remove empty tags
            .filter((tag, index, self) => self.indexOf(tag) === index); // Remove duplicates
        const name = document.getElementById('tile-name').value;
        const platform = document.getElementById('tile-platform').value;
        const age = document.getElementById('tile-age').value;
        const description = document.getElementById('tile-description').value;

        // Check for duplicate links
        const hasDuplicateLink = tiles.some(tile => tile.link === link);
        if (hasDuplicateLink) {
            const userResponse = confirm('A tile with this link already exists. Do you want to create a new tile with this duplicate link?');
            if (!userResponse) {
                document.getElementById('popup-overlay').style.display = 'block';
                return; // Don't create the tile if the user cancels
            }
        }

        const newTile = createTileData(imageSource, link, tags, name, platform, age, description);
        tiles.push(newTile);
        createImageTile(newTile);
        saveTiles();
        updateTagFilter();

        popup.style.display = 'none';
        document.getElementById('popup-overlay').style.display = 'none';
        clearTileCreationPopupInputs();
    };

    cancelBtn.onclick = () => {
        popup.style.display = 'none';
        document.getElementById('popup-overlay').style.display = 'none';
        clearTileCreationPopupInputs(); // Optional: Clear the inputs
    };
}



// Filter tiles when tag is selected
tagFilter.addEventListener('change', filterTiles);

// Export functionality
exportBtn.addEventListener('click', () => {
   const dataStr = JSON.stringify(tiles);
   const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
   const exportFileDefaultName = 'image_grid_data.json';

   const linkElement = document.createElement('a');
   linkElement.setAttribute('href', dataUri);
   linkElement.setAttribute('download', exportFileDefaultName);
   linkElement.click();
});

// Import functionality
importBtn.addEventListener('click', () => {
   importFileInput.click();
});

importFileInput.addEventListener('change', (event) => {
   const file = event.target.files[0];
   if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
         try {
            const importedTiles = JSON.parse(e.target.result);
            tiles = importedTiles;
            imageGrid.innerHTML = '';
            imageGrid.appendChild(addImageButton);
            tiles.forEach(tile => {
               createImageTile(tile);
               tile.tags.forEach(tag => allTags.add(tag));
            });
            saveTiles();
            updateTagFilter();
         } catch (error) {
            console.error('Error parsing imported data:', error);
            alert('Error importing data. Please make sure the file is in the correct format.');
         }
      };
      reader.readAsText(file);
   }
});
// Function to toggle blur on NSFW content
function toggleBlurNSFW() {
   const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; // Tags considered NSFW
   const imageItems = document.querySelectorAll('.image-item');

   imageItems.forEach(item => {
      const tags = Array.from(item.querySelectorAll('.tag')).map(tag => tag.textContent);

      if (nsfwTags.some(tag => tags.includes(tag))) {
         const img = item.querySelector('img');
         if (isBlurred) {
            img.style.filter = 'none'; // Unblur
         } else {
            img.style.filter = 'blur(10px)'; // Apply blur
         }
      }
   });

   // Toggle button text and blur state
   isBlurred = !isBlurred;
   localStorage.setItem('isBlurred', JSON.stringify(isBlurred)); // Save blur state in localStorage
   blurNSFWBtn.textContent = isBlurred ? 'Unblur NSFW' : 'Blur NSFW';
}
// Add event listener to the button
blurNSFWBtn.addEventListener('click', toggleBlurNSFW);
// Load saved tiles on page load
loadSavedTiles();
const randomCharacterBtn = document.getElementById('random-character-btn');
const settingsBtn = document.getElementById('settings-btn')
const characterPopup = document.getElementById('character-popup');
const popupClose = document.getElementById('popup-close');
const popupCloseBtn = document.getElementById('popup-close-btn');
const popupImage = document.getElementById('popup-image');
const popupTags = document.getElementById('popup-tags');

settingsBtn.addEventListener('click', () => {
      document.getElementById('settings-popup').style.display = 'flex';
      document.getElementById('popup-overlay').style.display = 'block';
});

// Event listeners for closing popup
popupClose.addEventListener('click', closePopup);
popupCloseBtn.addEventListener('click', closePopup);

// Function to pick a random character
function selectRandomCharacter() {

   const characters = Array.from(document.querySelectorAll('.image-item:not(.add-image)'));
   if (characters.length === 0) {
      alert('No characters available.');
      return;
   }
   let availableCharacters = includeNSFW ? characters : characters.filter(char => {
      const tags = Array.from(char.querySelectorAll('.tag')).map(tag => tag.textContent);
      return !tags.some(tag => ['18+', 'NSFW', 'Porn', 'Hentai', 'Yaoi', '🔞'].includes(tag));
   });

   if (availableCharacters.length === 0) {
      document.getElementById('popup-overlay').style.display = 'none';
      alert('No characters available with current NSFW settings. If you checked the box for it to remembner which option you chose, click the "Reset Remembered State" to get the prompt back up');
      return;

   }

   const randomIndex = Math.floor(Math.random() * availableCharacters.length);
   const selectedCharacter = availableCharacters[randomIndex];
   const tileData = tiles[characters.indexOf(selectedCharacter)];

   document.getElementById('popup-image').src = tileData.imageData;
   document.getElementById('popup-name').textContent = tileData.name || 'Unknown';
   document.getElementById('popup-platform').textContent = `Platform: ${tileData.platform || 'N/A'}`;
   document.getElementById('popup-age').textContent = `Age: ${tileData.age || 'N/A'}`;
   document.getElementById('popup-description').textContent = tileData.description || 'No description available.';
   document.getElementById('popup-tags').textContent = `Tags: ${tileData.tags.join(', ')}`;
   document.getElementById('popup-button').addEventListener('click', function() {
    const tileData = tiles[characters.indexOf(selectedCharacter)];
    window.open(tileData.link, '_blank'); // Open link in new tab
    });


   updateTileOutline(characterPopup, tileData.tags);

   if (isBlurred && (tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn') || tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞'))) {
      popupImage.classList.add('blurred-image');
   } else {
      popupImage.classList.remove('blurred-image');
   }

   characterPopup.classList.remove('hidden');
   document.getElementById('character-popup').style.display = 'block';
   document.getElementById('popup-overlay').style.display = 'block';

}
// Modify the closePopup function
function closePopup() {
   document.getElementById('popup-overlay').style.display = 'none';
   document.getElementById('character-popup').style.display = 'none';
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   characterPopup.classList.add('hidden');
   characterPopup.classList.remove('nsfw-outline');
   popupImage.classList.remove('blurred-image');
}

// Event listener for the random character button
randomCharacterBtn.addEventListener('click', () => {
    // Check if any character has the NSFW tag
    const hasNSFWCharacter = tiles.some(tile => tile.tags.includes('NSFW') || tile.tags.includes('18+') || tile.tags.includes('Porn') || tile.tags.includes('Hentai') || tile.tags.includes('Yaoi') || tile.tags.includes('🔞'));
    
    // Check if all tiles have the NSFW tag
    const allTilesNSFW = tiles.every(tile => tile.tags.includes('NSFW') || tile.tags.includes('18+') || tile.tags.includes('Porn') || tile.tags.includes('Hentai') || tile.tags.includes('Yaoi') || tile.tags.includes('🔞'));

    if (!hasNSFWCharacter) {
        // If no NSFW characters exist, select a random character
        selectRandomCharacter();
    } else if (allTilesNSFW) {
        // If all tiles are NSFW, select a random character
        includeNSFW = true;
        selectRandomCharacter();
    } else if (rememberNSFWChoice) {
        // If the NSFW choice is remembered, select a random character
        selectRandomCharacter();
    } else {
        // Show NSFW inclusion popup if NSFW characters exist and choice is not remembered
        document.getElementById('nsfw-inclusion-popup').style.display = 'flex';
        document.getElementById('popup-overlay').style.display = 'block';
    }
});



// Update the checkbox state based on the saved choice
document.getElementById('remember-nsfw-state-checkbox').checked = rememberNSFWChoice;

document.getElementById('remember-nsfw-state-checkbox').addEventListener('change', (event) => {
   rememberNSFWChoice = event.target.checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
});

document.getElementById('include-nsfw-btn').addEventListener('click', () => {
   includeNSFW = true;
   rememberNSFWChoice = document.getElementById('remember-nsfw-state-checkbox').checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   selectRandomCharacter();
});

document.getElementById('exclude-nsfw-btn').addEventListener('click', () => {
   includeNSFW = false;
   rememberNSFWChoice = document.getElementById('remember-nsfw-state-checkbox').checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   selectRandomCharacter();
});


// Event listener for the reroll button
document.getElementById('reroll-btn').addEventListener('click', selectRandomCharacter);

function checkForSpecialTiles() {
   const tileElements = document.querySelectorAll('.image-item:not(.add-image)');
   tileElements.forEach((tileElement, index) => {
      const tileData = tiles[index];
      if (
         (tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn')|| tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞')) &&
         (tileData.tags.includes('⭐') || tileData.tags.includes('✨') || tileData.tags.includes('🌠') || tileData.tags.includes('🌟') ||
          tileData.tags.includes('💫') || tileData.tags.includes('🤩') || tileData.tags.includes('❇️') || tileData.tags.includes('✴️') ||
          tileData.tags.includes('✳️') || tileData.tags.includes('🔥') || tileData.tags.includes('💎'))
      ) {
         tileElement.classList.add('special-outline');
      } else {
         tileElement.classList.remove('special-outline');
      }
   });
}

// Run the check once on page load
document.addEventListener('DOMContentLoaded', checkForSpecialTiles);

// Function to apply blur status on page load
function applyBlurNSFWStatus() {
   const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; // Tags considered NSFW
   const imageItems = document.querySelectorAll('.image-item');

   imageItems.forEach(item => {
      const tags = Array.from(item.querySelectorAll('.tag')).map(tag => tag.textContent);

      if (nsfwTags.some(tag => tags.includes(tag))) {
         const img = item.querySelector('img');
         img.style.filter = isBlurred ? 'blur(10px)' : 'none'; // Apply or remove blur
      }
   });

   blurNSFWBtn.textContent = isBlurred ? 'Unblur NSFW' : 'Blur NSFW'; // Set button text based on status
}

// Add event listener to the button
blurNSFWBtn.addEventListener('click', toggleBlurNSFW);

// Apply blur status when the page loads
document.addEventListener('DOMContentLoaded', applyBlurNSFWStatus);

document.getElementById('flush-button').addEventListener('click', () => {
    rememberNSFWChoice = false;
    includeNSFW = false;  // Set to false instead of true
    document.getElementById('remember-nsfw-state-checkbox').checked = false;
    localStorage.setItem('rememberNSFWChoice', JSON.stringify(rememberNSFWChoice));
    localStorage.setItem('includeNSFW', JSON.stringify(includeNSFW));
});
    </script>
</body>
</html>
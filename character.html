<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Bookmarking Tool</title>
    <style>      
        :root {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --tile-bg: #fff;
            --tile-shadow: rgba(0,0,0,0.1);
            --add-tile-bg: #e0e0e0;
            --add-tile-hover: #d0d0d0;
            --button-bg: #4c8247;
            --button-bg-hover: #43713e;
            --button-color: white;
            --popup-color: #dfdfdf;
        }

        .dark-mode {
            --bg-color: #333;
            --text-color: #f4f4f4;
            --tile-bg: #555;
            --tile-shadow: rgba(0,0,0,0.3);
            --add-tile-bg: #444;
            --add-tile-hover: #666;
            --button-bg: #43713e;
            --button-bg-hover: #396135;
            --button-color: #f4f4f4;
            --popup-color: #2f2f2f;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        h1,p {
            text-align: center;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .theme-toggle button, #tag-filter, #export-btn, #import-btn {
            padding: 5px 10px;
            cursor: pointer;
            background-color: var(--button-bg);
            color: var(--button-color);
            border: none;
            border-radius: 4px;
            margin-right: 5px;
        }

        .theme-toggle button:hover, #tag-filter:hover, #export-btn:hover, #import-btn:hover {
            background-color: var(--button-bg-hover)
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .image-item {
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: var(--tile-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px var(--tile-shadow);
        }

        .image-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        img {
            min-width: 100%;
            min-height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        img:hover {
            transform: scale(1.05);
        }

        .add-image {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--add-tile-bg);
            cursor: pointer;
            font-size: 48px;
            transition: background-color 0.3s ease;
        }

        .add-image:hover {
            background-color: var(--add-tile-hover);
        }
        
        #file-input, #import-file-input, .popup.hidden{
            display: none;
        }

        .tile-buttons {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            flex-wrap: wrap;
        }

        .tile-buttons button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 5px;
            margin-bottom: 3px;
        }

        .tags {
            position: absolute;
            bottom: 5px;
            left: 5px;
            display: flex;
            flex-wrap: wrap;
        }

        .tag {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 3px;
            margin-bottom: 3px;
        }

        .tag:hover{
            background-color: rgba(0, 0, 0, 0.7);
        }
        @media screen and (max-width: 600px) {
            .image-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }

        #popup-close-btn {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #popup-close-btn:hover {
            background-color: #e53935;
        }

        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--popup-color);
            border: 2px solid #000;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 300px;
        }

        #popup-content {
            text-align: center;
            position: relative;
            z-index: 1010;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1000;
        }

        #popup-image {
           width: 230px;
           height: 230px;
           object-fit: cover;  
            border-radius: 8px;
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .nsfw-outline, .popup.nsfw-outline {
            border: 3px solid red;
        }

        .blurred-image {
            filter: blur(10px);
        }
        .star-outline {
            border: 3px solid green;
        }
    </style>
</head>
<body>
    <h1>Character Bookmarking Tool</h1>
    <p>Found a character on an AI platform that is interesting, unique, or just find overal enjoyable to interact with? This tool allows you to easily bookmark the character so that you don't forget about it!</p>
    <p>To bookmark a character; Firstly click the "+" button to curate a new tile. This will appear at the end of the grid. You will be prompted to upload an image from your device, then prompted to include a hyperlink that will be associated with that tile. Finally you'll be prompted to add tags to the image (this is optional but can help with further organisation.) After you've done all of this the tile should appear on the grid. If you click/tap the grid image it will redirect you to the link that is associated with that tile. So if you were to link https://twitter.com to a tile, clicking/tapping it would bring you to Twitter.</p>
    <p>If you want to update the tags associated with a tile, click the üè∑Ô∏è button on the tile and you'll be prompted to be able to change the tags.</p>
    <p>If you want to update the image, click the üñºÔ∏è button on the tile, skip the hyperlink prompt (included through the same button) and provide a html link to the image.</p>
    <p>If you want to update the hyperlink attached to the tile, click the üñºÔ∏è button on the tile and change the hyperlink. If you don't want to change the image, just ignore the prompt to change it afterwards.</p>
    <p><b>Note: I recommend strongly that you export the data whenever you make changes (update tiles, add tiles, remove tiles) as the data is stored locally. So if you are to switch browers, switch devices, or for whatever reason the cookies/website data is deleted, any data on the website will be deleted in the process. When you export your data you'll get prompted to save a .json file, keep this and use it to import the data through the "import" button.</b></p>
    <div class="controls">
        <div class="theme-toggle">
            <button id="light-mode">Light Mode</button>
            <button id="dark-mode">Dark Mode</button>
            <button id="export-btn">Export</button>
            <button id="import-btn">Import</button>
            <button id="blur-nsfw-btn">Blur NSFW</button>
            <button id="random-character-btn">Select Random Character</button>
        </div>    
        <select id="tag-filter">
            <option value="all">All Tags</option>
        </select>
    </div>
<!-- Popup Structure -->
<div id="character-popup" class="popup hidden">
    <div id="popup-content">
        <span id="popup-close">&times;</span>
        <div id="popup-info">
            <img id="popup-image" src="" alt="Character Image">
            <p id="popup-tags"></p>
            <a id="popup-link" href="#" target="_blank">View Profile</a>
            <button id="popup-close-btn">Close</button> <!-- New close button -->
        </div>
    </div>
</div>
    <div class="image-grid" id="image-grid">
        <div class="image-item add-image" id="add-image">
            +
        </div>
    </div>
    <input type="file" id="file-input" accept="image/*">
    <input type="file" id="import-file-input" accept="application/json">

    <script>
        const imageGrid = document.getElementById('image-grid');
        const addImageButton = document.getElementById('add-image');
        const fileInput = document.getElementById('file-input');
        const lightModeBtn = document.getElementById('light-mode');
        const darkModeBtn = document.getElementById('dark-mode');
        const tagFilter = document.getElementById('tag-filter');
        const exportBtn = document.getElementById('export-btn');
        const importBtn = document.getElementById('import-btn');
        const importFileInput = document.getElementById('import-file-input');
        const blurNSFWBtn = document.getElementById('blur-nsfw-btn');

        let tiles = [];
        let allTags = new Set();
        let isBlurred = false; // Track blur status
        
        // Theme management
        function setTheme(theme) {
            document.body.className = theme;
            localStorage.setItem('theme', theme);
        }

        function applyStoredTheme() {
            const storedTheme = localStorage.getItem('theme') || '';
            setTheme(storedTheme);
        }

        lightModeBtn.addEventListener('click', () => setTheme(''));
        darkModeBtn.addEventListener('click', () => setTheme('dark-mode'));

        // Apply theme on load
        applyStoredTheme();

        // Load saved tiles
        function loadSavedTiles() {
            tiles = JSON.parse(localStorage.getItem('imageTiles')) || [];
            tiles.forEach(tile => {
                createImageTile(tile);
                tile.tags.forEach(tag => allTags.add(tag));
            });
            updateTagFilter();
        }

        // Save tiles
        function saveTiles() {
            localStorage.setItem('imageTiles', JSON.stringify(tiles));
        }

        // Create image tile
        function createImageTile(tileData) {
            const newImageItem = document.createElement('div');
            newImageItem.className = 'image-item';
            if (tileData.tags.includes('18+')) {
                newImageItem.classList.add('nsfw-outline');
            }
            if (tileData.tags.includes('‚≠ê')) {
                newImageItem.classList.add('star-outline');
            }
            newImageItem.innerHTML = `
                <a href="${tileData.link}" target="_blank" class="image-container">
                    <img src="${tileData.imageData}" alt="User uploaded image">
                </a>
                <div class="tile-buttons">
                    <button class="edit-image-btn" title="Edit Image">üñºÔ∏è</button>
                    <button class="edit-url-btn" title="Edit URL">üîó</button>
                    <button class="edit-tags-btn" title="Edit Tags">üè∑Ô∏è</button>
                    <button class="share-btn" title="Share">üì§</button>
                    <button class="delete-btn" title="Delete">√ó</button>
                </div>
                <div class="tags">
                    ${tileData.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
            `;
            imageGrid.insertBefore(newImageItem, addImageButton);

            // Add edit image functionality
            newImageItem.querySelector('.edit-image-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                editImage(tileData, newImageItem);
            });

            // Add edit tags functionality
            newImageItem.querySelector('.edit-tags-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                editTags(tileData, newImageItem);
            });

            // Add share functionality
            newImageItem.querySelector('.share-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                shareTile(tileData);
            });

            // Add delete functionality
            newImageItem.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteTile(tileData, newImageItem);
            });

            // Add edit URL functionality
            newImageItem.querySelector('.edit-url-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                editUrl(tileData, newImageItem);
            });
        }

        // Edit image
    function editImage(tileData, tileElement) {
    // Create an input element to upload a new image
    const imageUploadInput = document.createElement('input');
    imageUploadInput.type = 'file';
    imageUploadInput.accept = 'image/*'; // Accept image files only

    // Listen for the file selection
    imageUploadInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                const newImageData = e.target.result;
                // Update the tile with the new image
                tileData.imageData = newImageData;
                tileElement.querySelector('img').src = newImageData;

                saveTiles(); // Save changes after the image has been updated
            };

            // Read the image file as a data URL
            reader.readAsDataURL(file);
        }
    });

    // Trigger the file input
    imageUploadInput.click();
}


        // Edit tags
        function editTags(tileData, tileElement) {
            const newTags = prompt("Enter tags separated by commas:", tileData.tags.join(', '));
            if (newTags !== null) {
                tileData.tags = newTags.split(',').map(tag => tag.trim()).filter(tag => tag);
                updateTileTags(tileElement, tileData.tags);
                
                // Check for 18+ and ‚≠ê tags and update outlines
                tileElement.classList.toggle('nsfw-outline', tileData.tags.includes('18+'));
                tileElement.classList.toggle('star-outline', tileData.tags.includes('‚≠ê'));
                
                saveTiles();
                updateTagFilter();
            }
        }
        
        // Share tile
        function shareTile(tileData) {
            navigator.clipboard.writeText(tileData.link).then(() => {
                alert("Link copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        // Delete tile
        function deleteTile(tileData, tileElement) {
            tiles = tiles.filter(tile => tile !== tileData);
            imageGrid.removeChild(tileElement);
            saveTiles();
            updateTagFilter();
        }

        // Update tile tags
        function updateTileTags(tileElement, tags) {
            const tagsContainer = tileElement.querySelector('.tags');
            tagsContainer.innerHTML = tags.map(tag => `<span class="tag">${tag}</span>`).join('');
            updateAllTags();
        }

        // Update all tags
        function updateAllTags() {
            allTags.clear();
            tiles.forEach(tile => tile.tags.forEach(tag => allTags.add(tag)));
            updateTagFilter();
        }

        // Update tag filter dropdown
        function updateTagFilter() {
            const currentFilter = tagFilter.value;
            tagFilter.innerHTML = '<option value="all">All Tags</option>';
            allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            });
            tagFilter.value = currentFilter;
            filterTiles();
        }

        // Filter tiles based on selected tag
        function filterTiles() {
            const selectedTag = tagFilter.value;
            tiles.forEach((tile, index) => {
                const tileElement = imageGrid.children[index];
                if (selectedTag === 'all' || tile.tags.includes(selectedTag)) {
                    tileElement.style.display = '';
                } else {
                    tileElement.style.display = 'none';
                }
            });
        }

        // Handle file selection
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageData = e.target.result;
                    const link = prompt("Enter a link for this image:", "https://");
                    if (link) {
                        const tags = prompt("Enter tags separated by commas:").split(',').map(tag => tag.trim()).filter(tag => tag);
                        const newTile = { imageData, link, tags };
                        tiles.push(newTile);
                        createImageTile(newTile);
                        saveTiles();
                        updateTagFilter();
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        // Trigger file input when add button is clicked
        addImageButton.addEventListener('click', () => {
            fileInput.click();
        });

        // Filter tiles when tag is selected
        tagFilter.addEventListener('change', filterTiles);

        // Export functionality
        exportBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify(tiles);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportFileDefaultName = 'image_grid_data.json';

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        });

        // Import functionality
        importBtn.addEventListener('click', () => {
            importFileInput.click();
        });

        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedTiles = JSON.parse(e.target.result);
                        tiles = importedTiles;
                        imageGrid.innerHTML = '';
                        imageGrid.appendChild(addImageButton);
                        tiles.forEach(tile => {
                            createImageTile(tile);
                            tile.tags.forEach(tag => allTags.add(tag));
                        });
                        saveTiles();
                        updateTagFilter();
                    } catch (error) {
                        console.error('Error parsing imported data:', error);
                        alert('Error importing data. Please make sure the file is in the correct format.');
                    }
                };
                reader.readAsText(file);
            }
        });
// Function to toggle blur on NSFW content
function toggleBlurNSFW() {
    const nsfwTags = ['18+']; // Tags considered NSFW
    const imageItems = document.querySelectorAll('.image-item');

    imageItems.forEach(item => {
        const tags = Array.from(item.querySelectorAll('.tag')).map(tag => tag.textContent);

        if (nsfwTags.some(tag => tags.includes(tag))) {
            const img = item.querySelector('img');
            if (isBlurred) {
                img.style.filter = 'none'; // Unblur
            } else {
                img.style.filter = 'blur(10px)'; // Apply blur
            }
        }
    });

    // Toggle button text and blur state
    isBlurred = !isBlurred;
    blurNSFWBtn.textContent = isBlurred ? 'Unblur NSFW' : 'Blur NSFW';
}

// Add event listener to the button
blurNSFWBtn.addEventListener('click', toggleBlurNSFW);
        // Load saved tiles on page load
        loadSavedTiles();
        const randomCharacterBtn = document.getElementById('random-character-btn');
const characterPopup = document.getElementById('character-popup');
const popupContent = document.getElementById('popup-content');
const popupClose = document.getElementById('popup-close');
const popupCloseBtn = document.getElementById('popup-close-btn');
const popupImage = document.getElementById('popup-image');
const popupTags = document.getElementById('popup-tags');
const popupLink = document.getElementById('popup-link');

// Close popup function
function closePopup() {
    characterPopup.classList.add('hidden');
    characterPopup.classList.remove('red-border');
}

// Event listeners for closing popup
popupClose.addEventListener('click', closePopup);
popupCloseBtn.addEventListener('click', closePopup);


// Function to pick a random character
function selectRandomCharacter() {
            const characters = Array.from(document.querySelectorAll('.image-item:not(.add-image)'));
            if (characters.length === 0) {
                alert('No characters available.');
                return;
            }

            // Pick a random character
            const randomIndex = Math.floor(Math.random() * characters.length);
            const selectedCharacter = characters[randomIndex];

            // Extract data
            const imageSrc = selectedCharacter.querySelector('img').src;
            const linkHref = selectedCharacter.querySelector('a').href;
            const tags = Array.from(selectedCharacter.querySelectorAll('.tag')).map(tag => tag.textContent);

            // Populate the popup
            popupImage.src = imageSrc;
            popupLink.href = linkHref;
            popupTags.textContent = `Tags: ${tags.join(', ')}`;

            // Check for 18+ tag and apply red border if found
            if (tags.includes('18+')) {
                characterPopup.classList.add('nsfw-outline');
                // Apply blur if NSFW blur is enabled
                if (isBlurred) {
                    popupImage.classList.add('blurred-image');
                } else {
                    popupImage.classList.remove('blurred-image');
                }
            } else {
                characterPopup.classList.remove('nsfw-outline');
                popupImage.classList.remove('blurred-image');
            }

            // Show the popup
            characterPopup.classList.remove('hidden');
        }

        // Modify the closePopup function
        function closePopup() {
            characterPopup.classList.add('hidden');
            characterPopup.classList.remove('nsfw-outline');
            popupImage.classList.remove('blurred-image');
        }

// Event listener for the random character button
randomCharacterBtn.addEventListener('click', selectRandomCharacter);
function editUrl(tileData, tileElement) {
    // Prompt the user for a new URL
    const newUrl = prompt("Enter a new URL for this tile:", tileData.link);

    // If the user provided a URL (and didn't leave it blank), update the link
    if (newUrl !== null && newUrl.trim() !== "") {
        tileData.link = newUrl.trim();
        tileElement.querySelector('a').href = tileData.link;

        // Save changes
        saveTiles();
    }
}
    </script>
</body>
</html>
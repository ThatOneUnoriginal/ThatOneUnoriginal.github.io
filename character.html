<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="https://github.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/raw/refs/heads/main/Character%20Tools/Assets/Bookmark_Website_Logo.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="pinterest" content="nopin" />
    <link id="font-link" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap">
    <title>Character Bookmarking Tool: T1U Tools</title>
    
    <style>
    
.cancelButtonXyZwv, .compressionButtonQwErAs, .resizeButtonRtYuIo, #flush-button, .buttonHgFdSa, .theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #import-btn, #tile-size, #settings-btn1, #settings-btn2, #colorSelector, #popup-button, #reroll-btn, #local-upload-btn, #url-upload-btn,
#url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, #url-popup-close-url1, #popup-close, .collapsible, .edit-popup button,
#submit-url-btn, #submit-url-btn1, #share-url-popup button, #nsfw-inclusion-popup button, #image-upload-choice-popup button, #tile-creation-popup button, #settings-popup button, 
#tileSize, #undo-delete-popup button, #popup-close-btn, #new-confirm-image-btn, #confirm-image-btn, #new-cancel-image-btn, #cancel-image-btn, #image-confirmation-popup button,
#new-image-confirmation-popup button, #optToggleButton, .link-button, #close-links-popup, #accessibility-popup button, #theme-dropdown-accessibility, #close-multi-links-popup, #font-dropdown, #close-formatting, #acccessibility-btn1{
	background-color: var(--button-bg-1);
}



#character-popup {
	width: 90%;
	max-width: 600px;
	margin: 0 auto;
	overflow: scroll;
}

#edit-description-input, #tile-description, .custom-field-value {
    resize: vertical; /* Allow vertical resizing only */
    overflow: auto; /* Enable scrolling if content overflows */
}

#popup-content {
    overflow-y: auto;
	display: flex;
	flex-direction: column;
	align-items: center;
	width: 100%
}

#tile-creation-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
}

#tile-creation-popup input, #tile-creation-popup textarea {
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

#tile-creation-popup button, #new-confirm-image-btn, #confirm-image-btn, #new-cancel-image-btn, #cancel-image-btn  {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	margin-top: 10px;
    width: 100%
}

.highlight {
	background-color: var(--button-bg-1);
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-nsfw {
	background-color: var(--nsfw-color-1);
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-favourite {
	background-color: green;
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

.highlight-special {
	background-color: purple;
	color: var(--button-color);
	padding: 2px 5px;
	border-radius: 3px;
}

:root {
	--button-bg-1: #3e6e3e;
	--button-bg-2: #4c6b3b;
	--button-bg-3: #5c8a3b;
	--button-bg-4: #3e6e96;

	--button-bg-hover-1: #2c5a2c;
	--button-bg-hover-2: #3b5a32;
	--button-bg-hover-3: #4a6a32;
	--button-bg-hover-4: #2c5a74;

	--nsfw-color-1: #FF1A1A;
	--nsfw-color-2: #FF6A6A;
	--nsfw-color-3: #FF7F7F;
	--nsfw-color-4: #FF6A6A;

	--special-outline-color-1: #3B0056;
	--special-outline-color-2: #A88DFF;
	--special-outline-color-3: #9C51C4;
	--special-outline-color-4: #7B5DAF;

	--star-outline-color-1: #2E5B2E;
	--star-outline-color-2: #7B6B3A;
	--star-outline-color-3: #B7C20E;
	--star-outline-color-4: #4E4B31;

	--bg-color: #f4f4f4;
	--text-color: #333;
	--tile-bg: #fff;
	--tile-shadow: rgba(0, 0, 0, 0.1);
	--add-tile-bg: #e0e0e0;
	--add-tile-hover: #d0d0d0;
	--button-color: white;
	--popup-color: #dfdfdf;
    --tile-edit: rgba(0, 0, 0, 0.5);
}

.dark-mode {
	--button-bg-1: #4f8b4f;
	--button-bg-2: #5f8b4f;
	--button-bg-3: #6f9b4f;
	--button-bg-4: #4f8b96;

	--button-bg-hover-1: #3e6b3e;
	--button-bg-hover-2: #4d6b3e;
	--button-bg-hover-3: #5c7b3e;
	--button-bg-hover-4: #3e6b8a;

	--nsfw-color-1: #FF7F7F;
	--nsfw-color-2: #FF8A8A;
	--nsfw-color-3: #FF8A8A;
	--nsfw-color-4: #FF8A8A;

	--special-outline-color-1: #D78FFF;
	--special-outline-color-2: #D6A5FF;
	--special-outline-color-3: #A66CBB;
	--special-outline-color-4: #B57EDB;

	--star-outline-color-1: #A8FF4C;
	--star-outline-color-2: #B7B73A;
	--star-outline-color-3: #D2D700;
	--star-outline-color-4: #7A7B35;
	--bg-color: #333;
	--text-color: #f4f4f4;
	--tile-bg: #555;
	--tile-shadow: rgba(0, 0, 0, 0.3);
	--add-tile-bg: #444;
	--add-tile-hover: #666;
	--button-color: #f4f4f4;
	--popup-color: #2f2f2f;
    --tile-edit: rgba(0, 0, 0, 0.5);
}

.high-contrast-light-mode {
	--button-bg-1: #3C6E3D; /* Dark green */
	--button-bg-2: #4C8A3B; /* Medium green */
	--button-bg-3: #5CAC3A; /* Bright green */
	--button-bg-4: #3E8FBB; /* Dark blue */

	--button-bg-hover-1: #2A4C2A; /* Darker green */
	--button-bg-hover-2: #3A6B30; /* Darker medium green */
	--button-bg-hover-3: #4A9E31; /* Darker bright green */
	--button-bg-hover-4: #2A6D92; /* Darker blue */

	--nsfw-color-1: #D00000; /* Bright red */
	--nsfw-color-2: #FF4C4C; /* Light red */
	--nsfw-color-3: #FF7F7F; /* Pale red */
	--nsfw-color-4: #FF4C4C; /* Light red */

	--special-outline-color-1: #5D005C; /* Dark purple */
	--special-outline-color-2: #BF8DFF; /* Light purple */
	--special-outline-color-3: #A752C4; /* Medium purple */
	--special-outline-color-4: #A760AF; /* Medium dark purple */

	--star-outline-color-1: #3B7A3B; /* Bright dark green */
	--star-outline-color-2: #B1A635; /* Bright brown */
	--star-outline-color-3: #D0D20E; /* Bright yellow */
	--star-outline-color-4: #7B6E31; /* Bright dark gray */

	--bg-color: #FFFFFF; /* White */
	--text-color: #222222; /* Very dark gray */
	--tile-bg: #F9F9F9; /* Light gray */
	--tile-shadow: rgba(0, 0, 0, 0.15); /* Slightly darker shadow */
	--add-tile-bg: #D7D7D7; /* Light gray */
	--add-tile-hover: #C7C7C7; /* Slightly darker gray */
	--button-color: #FFFFFF; /* White for buttons */
	--popup-color: #EFEFEF; /* Light gray */
	--tile-edit: rgb(0, 0, 0); /* Darker edit overlay */
}


.high-contrast-dark-mode {
	--button-bg-1: #007f00; /* Darker, more distinct green */
	--button-bg-2: #008000;
	--button-bg-3: #009000;
	--button-bg-4: #005f7f; /* More distinct blue-green */

	--button-bg-hover-1: #005f00; /* Even darker hover colors for distinction */
	--button-bg-hover-2: #006000;
	--button-bg-hover-3: #007000;
	--button-bg-hover-4: #004d6f;

	--nsfw-color-1: #FF0000; /* Bright red for high visibility */
	--nsfw-color-2: #FF3333;
	--nsfw-color-3: #FF3333;
	--nsfw-color-4: #FF3333;

	--special-outline-color-1: #BF00FF; /* Brighter purple */
	--special-outline-color-2: #CF33FF;
	--special-outline-color-3: #A000BF;
	--special-outline-color-4: #C400E0;

	--star-outline-color-1: #FFFF00; /* Bright yellow for visibility */
	--star-outline-color-2: #FFFF66;
	--star-outline-color-3: #FFFF33;
	--star-outline-color-4: #E0E000;

	--bg-color: #000; /* Black background for maximum contrast */
	--text-color: #FFFFFF; /* White text for high contrast */
	--tile-bg: #222; /* Darker tiles for contrast against background */
	--tile-shadow: rgba(255, 255, 255, 0.5); /* Light shadow for distinction */
	--add-tile-bg: #111;
	--add-tile-hover: #333;
	--button-color: #FFFFFF; /* White text on buttons for contrast */
	--popup-color: #000; /* Black popup background for consistency */
    --tile-edit: rgb(0, 0, 0);
}

.amoled-mode {

	--button-bg-1: #2e5e2e;
	--button-bg-2: #3e5e2e;
	--button-bg-3: #4e6e2e;
	--button-bg-4: #2e5e6a;

	--button-bg-hover-1: #3e6b3e;
	--button-bg-hover-2: #4d6b3e;
	--button-bg-hover-3: #5c7b3e;
	--button-bg-hover-4: #3e6b8a;

	--nsfw-color-1: #C05050;
	--nsfw-color-2: #C06A6A;
	--nsfw-color-3: #D06A6A;
	--nsfw-color-4: #C0507A;

	--special-outline-color-1: #A052B1;
	--special-outline-color-2: #A06EB1;
	--special-outline-color-3: #B06EB1;
	--special-outline-color-4: #A052C6;

	--star-outline-color-1: #7D9A3C;
	--star-outline-color-2: #8B9A3C;
	--star-outline-color-3: #9B9A3C;
	--star-outline-color-4: #7D9A6A;

	--bg-color: #000;
	--text-color: #e0e0e0;
	--tile-bg: #111;
	--tile-shadow: rgba(255, 255, 255, 0.1);
	--add-tile-bg: #222;
	--add-tile-hover: #333;
	--button-color: #e0e0e0;
	--popup-color: #111;
    --tile-edit: rgba(0, 0, 0, 0.5);
}

body {
	font-family: Arial, sans-serif;
	line-height: 1.6;
	margin: 0;
	padding: 20px;
	background-color: var(--bg-color);
	color: var(--text-color);
	transition: background-color 0.3s, color 0.3s;
}

h1,
p {
	text-align: left;
}

.controls {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 20px;
}

#edit-info-popup input, #edit-info-popup textarea {
	width: 100%;
	box-sizing: border-box;
	margin-bottom: 10px;
}

.theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #import-btn, #tile-size, #acccessibility-btn1, #settings-btn1, #settings-btn2, #flush-button, #optToggleButton {
	padding: 5px 10px;
	cursor: pointer;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	margin-right: 5px;
	margin-bottom: 10px;
}

#tag-filter-mobile {
	width: 100%;
	display: none;
    text-align: center;
}

.image-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	gap: 20px;
	padding: 20px;
}

.image-item {
	aspect-ratio: 1 / 1;
	position: relative;
	background-color: var(--tile-bg);
	border-radius: 8px;
	overflow: hidden;
	box-shadow: 0 2px 4px var(--tile-shadow);
}
#popup-image{
    aspect-ratio: 1/1;
}
.image-container {
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	overflow: hidden;
}

img {
	min-width: 100%;
	min-height: 100%;
	object-fit: cover;
	transition: transform 0.3s ease;
}

.add-image {
	display: flex;
	justify-content: center;
	align-items: center;
	background-color: var(--add-tile-bg);
	cursor: pointer;
	font-size: 48px;
	transition: background-color 0.3s ease;
}

.add-image:hover {
	background-color: var(--add-tile-hover);
}

#file-input, #import-file-input, .popup.hidden {
	display: none;
}

.hidden {
	display: none;
}

.tile-buttons {
	position: absolute;
	top: 5px;
	right: 5px;
	display: flex;
	flex-wrap: wrap;
}

.tile-buttons button {
	background-color: var(--tile-edit);
	color: white;
	border: none;
	border-radius: 50%;
	width: 30px;
	height: 30px;
	font-size: 15px;
	cursor: pointer;
	display: flex;
	justify-content: center;
	align-items: center;
	margin-left: 5px;
	margin-bottom: 5px;
}

.tags {
	position: absolute;
	bottom: 5px;
	left: 5px;
	display: flex;
	flex-wrap: wrap;
}

.tag {
	background-color: var(--tile-edit);
	color: white;
	padding: 2px 5px;
	border-radius: 3px;
	font-size: 12px;
	margin-right: 3px;
	margin-bottom: 3px;
}

.tag:hover {
	background-color: rgba(0, 0, 0, 0.7);
}

@media screen and (max-width: 600px) {
	.image-grid {
		grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
	}
}

#popup-close-btn {
	margin-top: 10px;
	padding: 5px 10px;
	color: white;
	border: none;
	border-radius: 5px;
	cursor: pointer;
    transition: background-color 0.3s;
}


.popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: flex;
	flex-direction: column;
	align-items: center;
	max-width: 800px;
	animation: float 5s ease-in-out infinite;
}

.button-container {
   display: flex;
   gap: 10px; /* Adjust the space between the buttons */
   justify-content: flex-start; /* Align buttons to the left (optional) */
   width: 100%;
}

.button-container button {
   padding: 5px 10px; /* Optional: Adjust button padding */
}


@keyframes float {
	0% {
		transform: translate(-50%, -50%);
	}

	50% {
		transform: translate(-50%, -52%);
	}

	100% {
		transform: translate(-50%, -50%);
	}
}

#popup-image-container {
	flex: 0 0 auto;
	margin-right: 20px;
}

#popup-content {
	position: relative;
}

#popup-image, #preview-image, #new-preview-image {
	min-width: 250px;
    min-height: 250px;
	width: 250px;
	height: 250px;
	object-fit: cover;
	border-radius: 8px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	margin-bottom: 10px;
}

#popup-image, #preview-image:hover, #new-preview-image:hover {
	transform: scale(1)
}

.popup-info {
	flex: 1;
	background-color: rgba(255, 255, 255, 0.1);
	border-radius: 8px;
	padding: 15px;
	overflow-y: auto;
	max-height: 225px;
}

.popup-info h3 {
	margin-top: 0;
	border-bottom: 1px solid rgba(255, 255, 255, 0.3);
	padding-bottom: 5px;
}

.popup-info p {
	margin: 10px 0;
}

#popup-tags {
	font-style: italic;
}

#popup-button, #reroll-btn, #popup-close-btn {
	display: inline-block;
	margin-top: 15px;
	color: var(--button-color);
	padding: 8px 15px;
	border-radius: 4px;
	text-decoration: none;
	transition: background-color 0.3s;
	margin-bottom: 10px;
	border-color: transparent;
    width: 100%
}

#local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, #url-popup-close-url1 {
	display: inline-block;
	cursor: pointer;
	color: var(--button-color);
	padding: 8px 15px;
	border-radius: 4px;
	text-decoration: none;
	transition: background-color 0.3s;
	margin-bottom: 10px;
	border-color: transparent;
	width: 100%
}
#image-confirmation-popup, #new-image-confirmation-popup, #multi-links-popup, #formatting-guide{
    z-index: 1002 !important;
}
#popup-close{
	position: absolute;
	top: 10px;
	right: 15px;
	color: var(--button-color);
	width: 30px;
	height: 30px;
	border-radius: 50%;
	display: flex;
	justify-content: center;
	align-items: center;
	cursor: pointer;
	font-size: 18px;
	font-weight: bold;
	transition: background-color 0.3s;
}


#popup-close-btn {
	display: none;
}

.popup-overlay {
	position: fixed;
	display: none;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 999;
	backdrop-filter: blur(5px);
}

.popup-overlay1 {
	position: fixed;
	display: none;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 1001;
	backdrop-filter: blur(5px);
}

.nsfw-outline, .popup.nsfw-outline {
	border: 5px solid var(--nsfw-color-1);
	/* Default color */
}

.blurred-image {
	filter: blur(10px);
}

.star-outline {
	border: 5px solid var(--star-outline-color-1);
}
.full-width {
    width: 100%; 
    padding: 15px; 
}


.special-outline {
	border: 5px solid var(--special-outline-color-1);
}

#links-list li, #multi-links-list li {
    list-style-type: none;
    width: 100%;
}
#links-list, #multi-links-list{
    width: 100%;
    padding-left: 0px;
}


.collapsible {
	color: var(--button-color);
	cursor: pointer;
	padding: 18px;
	width: 100%;
	border: none;
	text-align: left;
    border-radius: 4px;
	outline: none;
	font-size: 15px;
	margin-bottom: 10px;
}

.collapsible:after {
	content: '\002B';
	color: var(--button-color);
	font-weight: bold;
	float: right;
	margin-left: 5px;
}

.active:after {
	content: "\2212";
}

.collapsible-content {
	padding: 0 18px;
	max-height: 0;
	overflow: hidden;
    border-radius: 4px;
	transition: max-height 0.2s ease-out, padding 0.2s ease-out;
	background-color: var(--tile-bg);
	margin-bottom: 10px;
}

.edit-popup, #image-popup, #image-source-popup, #url-input-popup, #url-popup, #new-image-confirmation-popup, #formatting-guide {
	position: fixed;
	top: 50%;
	left: 50%;
    overflow: scroll;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
	animation: float 5s ease-in-out infinite;
}

#formatting-guide, #edit-info-popup{
    max-height: 80%;
}
#formatting-guide h1, #formatting-guide h2, #formatting-guide p, #formatting-guide h3{
    text-align: center;
}
.edit-popup input, .edit-popup textarea, #image-url-input1, #image-url-input{
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

.edit-popup button, .link-button, #close-links-popup, #close-multi-links-popup, #close-formatting {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 100%;
	margin-top: 10px;
}

#submit-url-btn, #submit-url-btn1 {
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 100%;
	margin-top: 10px;
	margin-bottom: 10px;
}

.image-grid {
	--tile-size: 200px;
	--grid-gap: 20px;
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(var(--tile-size), 1fr));
	gap: var(--grid-gap);
	padding: 20px;
}

#share-url-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
	animation: float 5s ease-in-out infinite;
}

#share-url-popup input {
	width: 100%;
	padding: 10px;
	margin-bottom: 10px;
	border: 1px solid #ccc;
	border-radius: 4px;
}

#share-url-popup button {
	padding: 10px 20px;
	width: 100%;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	margin-top: 10px;
}

#nsfw-inclusion-popup, #settings-popup, .links-popup, #accessibility-popup, .multi-links-popup, #settings-popout {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
    text-align: center;
	max-width: 400px;
	width: 100%;
    max-height: 80%;
    overflow-y: scroll;
	animation: float 5s ease-in-out infinite
}

#nsfw-inclusion-popup button, #settings-popup button, #colorSelector, #tileSize, #accessibility-popup button, #theme-dropdown-accessibility, #font-dropdown, #settings-popout button{
	width: 100%;
	margin-top: 10px;
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
}

#image-upload-choice-popup {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: var(--popup-color);
	border: 2px solid #000;
	padding: 20px;
	border-radius: 15px;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
	z-index: 1000;
	display: none;
	flex-direction: column;
	align-items: center;
	max-width: 400px;
	width: 100%;
}

#image-upload-choice-popup button {
	margin: 10px;
	padding: 10px 20px;
	color: var(--button-color);
	border: none;
	border-radius: 4px;
	cursor: pointer;
	width: 80%;
}

#popup-button:hover, .cancelButtonXyZwv:hover, .compressionButtonQwErAs:hover, .resizeButtonRtYuIo:hover, .buttonHgFdSa:hover, #close-formatting:hover, #font-dropdown:hover, .theme-toggle button:hover, #tag-filter:hover, #tag-filter-mobile:hover, #export-btn:hover, #import-btn:hover, #image-upload-choice-popup button:hover, #nsfw-inclusion-popup button:hover, #theme-dropdown-accessibility:hover,
#share-url-popup button:hover, .edit-popup button:hover, .active, .collapsible:hover, #popup-close-btn:hover ,#popup-close:hover, #settings-popup button:hover, #undo-delete-popup button:hover, #new-confirm-image-btn:hover, #confirm-image-btn:hover,
#new-cancel-image-btn:hover, #cancel-image-btn:hover, #optToggleButton:hover, #image-confirmation-popup button:hover, #new-image-confirmation-popup button:hover, #settings-btn2:hover , #flush-button:hover, .link-button:hover, #close-multi-links-popup:hover, #close-links-popup:hover, #settings-btn1:hover, #accessibility-popup button:hover, #acccessibility-btn1:hover{
	background-color: var(--button-bg-hover-1)
}

#undo-delete-popup {
	position: fixed;
	bottom: 20px;
	left: 20px;
	background-color: var(--popup-color);
	color: var(--text-color);
	padding: 15px;
	border-radius: 5px;
	display: flex;
	align-items: center;
	justify-content: space-between;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
	z-index: 1000;
	opacity: 0;
	transform: translateY(20px);
	transition: opacity 0.3s, transform 0.3s;
}

#undo-delete-popup.show {
	opacity: 1;
	transform: translateY(0);
}

#undo-delete-popup p {
	margin: 0;
	margin-right: 15px;
}

#undo-delete-popup button {
	color: white;
	border: none;
	padding: 5px 10px;
	border-radius: 3px;
	cursor: pointer;
	transition: background-color 0.3s;
}

#dismiss-undo {
	background-color: transparent !important;
	color: #aaa;
	padding: 0 !important;
	margin-left: 10px;
}

#dismiss-undo:hover {
	color: #fff;
}

@media (max-width: 650px) {
	#undo-delete-popup {
		bottom: 0;
		left: 0;
		width: 100%;
		margin-left: 0;
		transform: none;
		padding: 20px;
		box-sizing: border-box;
	}
}

@media (max-height: 700px) {
    #settings-popup, #accessibility-popup{
        height: 80%;
    }
}
@media (max-width: 600px) {
	#character-popup {
		max-height: 80vh;
		overflow-y: auto;
        width: 80%;
	}

    #popup-close-btn{
        display: block
    }
    #popup-close{
        display: none
    }

	#popup-image {
		max-height: 200px;
		width: auto;
		object-fit: contain;
	}

	.popup-info {
		max-height: none;
	}

	.edit-popup, #share-url-popup, #nsfw-inclusion-popup, #image-popup, #image-source-popup, #url-input-popup, #url-popup, #settings-popup, #tile-creation-popup, #accessibility-popup {
		width: 80%;
		max-width: none;
		padding: 15px;
	}

	#accessibility-btn1, .edit-popup textarea, #nsfw-inclusion-popup button, #local-upload-btn, .edit-popup button, #share-url-popup button, #nsfw-inclusion-popup button, .theme-toggle button, 
    #export-btn, #settings-btn1, #flush-button, #optToggleButton, #settings-btn, #settings-btn2, #import-btn, #tile-size, #tag-filter-mobile, #local-upload-btn, #url-upload-btn, #url-popup-close, #colorSelector, #settings-popup button, #tileSize, #accessibility-popup button {
		width: 100%;
		margin-bottom: 15px;
		padding: 15px;
	}
    .edit-popup input, #image-url-input1, #image-url-input, #tile-link, #tile-tags, #tile-name, #tile-platform, #tile-age, #tile-description{
        width: 100% !important;
    }

	#share-url-popup input {
		width: 80%;
		margin-bottom: 15px;
		padding: 15px;
	}

	#popup-content {
		flex-direction: column;
	}

	#popup-image-container {
		margin-right: 0;
		margin-bottom: 20px;
	}

	#popup-image {
		width: 100%;
		height: auto;
	}

	.popup-info {
		max-height: none;
	}

	.tile-buttons button {
		width: 40px;
		height: 40px;
	}

	#tag-filter-mobile {
		display: block !important;
	}

	.tag {
		padding: 4px 10px;
	}

	#tag-filter {
		display: none !important;
    }
}
.no-animation {
    animation: none !important;
    transition: none !important;
}

.remove-custom-field-btn{
	margin-top: 0;
	margin-bottom: 15px;
}
blockquote {
    position: relative;
    padding: 1em; /* Space for the line */
    border-left: 4px solid var(--text-color); /* Optional: left border for styling */
}

.url-input-container {
   display: flex;
   flex-wrap: wrap;   /* Allows inputs to wrap within the container */
   justify-content: center;  /* Centers the inputs horizontally */
   max-width: 90%;    /* Ensures container does not exceed 90% of its parent */
   margin: 0 auto;    /* Centers container within the parent */
   padding: 10px;
   gap: 10px;         /* Adds space between input elements */
}

.url-input {
   flex: 1 1 45%;     /* Ensures inputs take up 45% of the width, allowing two per row */
   min-width: 200px;  /* Sets a minimum width for inputs to avoid being too small */
   box-sizing: border-box; /* Ensures padding and borders are included in the width calculation */
   padding: 8px;
}
.custom-field-key{
    margin-top: 10px;
}
.custom-field-value{
    margin-bottom: 0px !important;
}
/* Random CSS Class Names */
.popupQwErTy {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.imageContainerAsDfGh {
    position: relative;
    max-width: 80%;
    max-height: 80%;
}

.cropBoxZxCvBn {
    position: absolute;
    border: 2px solid white;
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
    cursor: move;
}

.resizeHandleUiOpLm {
    position: absolute;
    bottom: -10px;
    right: -10px;
    width: 20px;
    height: 20px;
    background-color: white;
    border: 2px solid black;
    cursor: se-resize;
}

.buttonHgFdSa {
    margin-top: 20px;
    padding: 10px 20px;
    color: var(--bg-color);
    border: none;
    cursor: pointer;
    font-size: 16px !important; /* Adjust the size as needed */    
    border-radius: 4px;
    z-index: 1;
}

.cancelButtonXyZwv {
    margin-top: 20px;
    padding: 10px 20px;
    color: var(--bg-color);
    border: none;
    cursor: pointer;
    border-radius: 4px;
    z-index: 1;
}

.compressionButtonQwErAs, .resizeButtonRtYuIo {
    margin-top: 20px;
    margin-left: 10px;
    padding: 10px 20px;
    color: var(--bg-color);
    border-radius: 4px;
    border: 0px;
    cursor: pointer;
    z-index: 1;
}


    </style>
</head>
<body>
    <h1>Character Bookmarking Tool</h1>
    <h2>Welcome to the Character Bookmarking Tool</h2>
    <button class="collapsible">Click here for more information (recommended for first time users)</button>
    <div class="collapsible-content">
       <p>Ever wanted a singular place to save all your favourite, interesting characters? Does the platform you're using not have the ability to bookmark/favourite characters? This tool allows you to bookmark the character so you don't forget about it.</p>
       <p>To bookmark a character:</p>
       <ul>
          <li>Go to the end of the grid and click the tile with the <span class="highlight">+</span> icon.</li>
          <li>Once you prompt the tile curation, you'll be asked to upload a file from your system.</li>
          <li>The file upload prompt will by default show all the files that are supported by the system (though some of the supposed "supported" file formats like .psp may not work.)</li>
          <li>
             After uploading an image, you'll be prompted to include:
             <ul>
                <li>A hyperlink</li>
                <li>Tags</li>
                <li>Character name</li>
                <li>Platform</li>
                <li>Character age</li>
                <li>Character description</li>
             </ul>
          </li>
       </ul>
       <p><strong>Note:</strong> Not all of these are required, but at minimum the <span class="highlight">hyperlink</span> should be added so that you're able to go to the character page when you click the tile. The other information makes remembering the details of the characters easier.</p>
       <p><strong>How to edit information?</strong></p>
       <p>Once you've curated the tile, you'll be able to edit all the information that you had inputted when curating the tile:</p>
       <ul>
          <li>Choose <span class="highlight">Edit Image</span> to change the image that is attached to the tile.</li>
          <li>Choose <span class="highlight">Edit URL</span> to change the hyperlink that the tile will direct towards when clicked.</li>
          <li>Choose <span class="highlight">Edit Tags</span> to change the tags associated with the tile.</li>
          <li>Choose <span class="highlight">Edit Info</span> to change the name, platform, age, and description.</li>
       </ul>
       <p><strong>How to indicate characters as NSFW?</strong></p>
       <p>When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, add one of the following tags:</p>
       <ul>
          <li>NSFW</li>
          <li>Hentai</li>
          <li>18+</li>
          <li>Porn</li>
          <li>Yaoi</li>
          <li>🔞</li>
       </ul>
       <p>They're case sensitive, so put them in as shown here. This will cause a <span class="highlight-nsfw">red outline</span> to appear around the tile and the random character popup if it's selected. You can also blur the image with the <span class="highlight">Blur NSFW</span> button in the <span class="highlight">Theme Settings</span> menu.</p>
       <p>Like the favourite system (bellow) the <span class="highlight">NSFW</span> tag will show all the above NSFW tags, though each individual one will appear in the tag filtering dropdown.</p>
       <p><strong>How to indicate characters as Favourites?</strong></p>
       <p>When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, add one of the following tags. This will cause a <span class="highlight-favourite">green outline</span> to appear around the tile and random character popup if it's selected.</p>
       <ul>
        <li>⭐</li>
        <li>🌠</li>
        <li>🤩</li>
        <li>🌟</li>
        <li>✨</li>
        <li>💫</li>
        <li>❇️</li>
        <li>✴️</li>
        <li>✳️</li>
       </ul>
       <p>Note that regardless of which ones you use (either one exclusively or a combination) when using the tag filtering dropdown they will be combined to a singular <span class="highlight-favourite">⭐</class> section.</p>
       <p><strong>Can I indicate a character as being NSFW and a Favourite?</strong></p>
       <p>Yes! When prompted to change the tags for the image either when curating the tile or choosing the Edit Tags button, adding one of the NSFW tag triggers and the Favourites tag trigger will cause a special <span class="highlight-special">purple outline</span> to appear on both the tile and random character popup if it's selected.</p>
       <p><strong>Should I Export?</strong></p>
       <p>Yes, it's recommended that you export your grid/list any time you make any changes to it. Everything is stored locally on the browser, so if anything happens (cookies reset, change browsers, change devices, etc...) the page will reset to be blank. If this happens, just use the Import button to bring back the characters. With the export/backup file, you'll also be able to use the Reorder Tool and Merge Tool.</p>
    </div>
    <button class="collapsible">Update Log (2.0.1 to 3.0)</button>
    <div class="collapsible-content">
        <h2>Update 2.2</h2>
        <ul>
            <li>Fixed problem where if the cropper was cancelled the overlay would not appear again covering over the image source.</li>
            <li>Fixed issue where font-size and font weight wouldn't apply to all buttons.</li>
            <li>Fixed problem where leftover "I Love Pixels" option was presented as an available compression option.</li>
            <li>Changed the styling of the cropping buttons to better match the theme of the website and ensured they comply with the colour blindness dropdown.</li>
            <li>Fixed problem where the remove custom value(s) buttons weren't complying with the colour blindness dropdown.</li>
            <li>If it has been 30 days since you last exported your data, you will be given a prompt reminding you to export your data to protect against data loss. Note that this is saved LOCALLY and isn't sent to any central server.</li>
            <li>Fixed problem where there would be white space on the Edit Info popup by switching <code>height: 80%</code> to <code>max-height: 80%</code>.</li>
            <li>Fixed problem where the Provide URL button when adding a new tile wouldn't comply with the colour blindness dropdown.</li>
            <li>Fixed problem where All Tags wouldn't respect the font weight selection.</li>
            <li>Fixed problem where the animation option wouldn't affect the formatting guide popup.</li>
            <li>Fixed another problem related to the export feature, which caused the feature to break the website.</li>
            <li>Fixed problem where <code>h2</code> wouldn't resize respective to the font size option.</li>
            <li>When editing the URL, tags, or info of a character, pressing the cancel button while there are unsaved changes will prompt the user to confirm if they want to reverse the changes.</li>
            <li>Compression level and Image Size are now saved to local storage, persisting across refreshes and when adding multiple images.</li>
            <li>You can now reorder custom values by pressing either the "Move Up" or "Move Down" buttons.</li>
            <li>Added a new accessibility option that allows you to change the vertical margins of all the buttons (minimum is 15px/10px).</li>
            <li>A new keybind for <code>(-)</code> has been added: <strong>Ctrl -</strong>.</li>
            <li>A new keybind for <code>(ind)</code> has been added: <strong>Ctrl + Shift + |</strong>.</li>
          </ul>          
        <h2>Update 2.1</h2>
        <ul>
            <li>Fixed the problem where clicking the popup overlays would try to find elements from the multi-link feature that no longer exist, causing it to fail.</li>
            <li>Fixed problem where if you were to delete multiple characters within quick succession, the undo delete feature would fail to work properly.</li>
            <li>When editing an existing tile, you can now add custom values in addition to the preset options. These custom values will be included alongside the defaults when using the random character feature.</li>
            <ul>
                <li>A new formatting system has been curated that can be used when editing custom values.</li>
                <ul>
                    <li><code>(-)</code> Add this to the beginning of a line to make it a list</li>
                    <li><code>(#)</code> Add this to the beginning to make it an ordered list
                        <ul>
                            <li>Pressing <code>Ctrl + Shift + #</code> will add this to the beginning of the line</li>
                        </ul>
                    </li>
                    <li><code>(ind)</code> Add this to add an indent</li>
                    <li><code>(b)(/b)</code> Wrap this around text to make it <strong>bold</strong>
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + B</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(i)(/i)</code> Wrap this around text to make it <em>italics</em>
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + I</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(u)(/u)</code> Wrap this around text to add an <u>underline</u>
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + U</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(s)(/s)</code> Wrap this around text to add <del>strikethrough</del>
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + S</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(c)(/c)</code> Wrap this around for <code>Inline Code</code>
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + K</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(q)(/q)</code> Wrap this around for blockquote
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + Q</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(sub)(/sub)</code> Wrap this around for subscript
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + =</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(sup)(/sup)</code> Wrap this around for superscript
                        <ul>
                            <li>Highlighting text and pressing <code>Ctrl + Shift + =</code> will wrap the text with this formatting</li>
                        </ul>
                    </li>
                    <li><code>(blur)(/blur)</code> Wrap this around to blur the text</li>
                    <li><code>(letterspace="")(/letterspace)</code> Wrap this around text to change the spacing between each letter within it (using {num}px)</li>
                    <li><code>(color="{color}")(/color)</code> Wrap this around text to change its colour</li>
                    <li><code>(bgcolor="{color}")(/bgcolor)</code> Wrap this around text to change its background color</li>
                    <li><code>(link="{hyperlink}")(/link)</code> Wrap this around text to make it a hyperlink</li>
                </ul>
            </ul>
            <li>When editing an image or adding a new tile and choosing the local image option, you will now be prompted to crop the image. This allows you to have more control of what the output image looks like (by default, it would just center to the image).</li>
            <ul>
                <li>You will now have the option to compress the image by multiple different levels. This will decrease the file size of the image though will sacrifice image quality. So use them in moderation alongside how much quality you're willing to lose.</li>
                <li>You will also have the option to resize the image by different levels. This will decrease the dimensions of the image, making them smaller. Note that I wouldn't recommend playing with this too much if you're already using the compression option since a combination of both can SIGNIFICANTLY reduce image quality.</li>            
            </ul>
            <li>Animated image formats will no longer work fully. They will be converted to a WEBP file and be stuck on the first frame when uploading locally.</li>
        </ul>
        
        <h2>Update 2.0.2eu1</h2>
        <ul>
            <li>An issue with the multi-link functionality in update 2.0 caused multiple other functions of the website to not work as intended. The website was rolled back to 1.9.1 as I fixed the issues. All changes that were made in 2.0, 2.0.1 and 2.0.2 should now be back except for the multi-link functionality. If you had used this feature, simply edit the URL of the tile with just one URL.</li>
        </ul>
        <h2>Update 2.0.2</h2>
        <ul>
            <li>Fixed problem where the platforms field would only appear in the tag filter list after editing the tags of the tile</li>
            <li>Fixed problem where long inputs for either the tags or the platform would cause the tags dropdown to expand in size excessively</li>
            <li>Removed Age from ever appearing on the tag dropdown</li>
            <li>You can now add multiple platforms to the platform section (previously it would treat the entire input as 1 option)</li>
        </ul>
        <h2>Update 2.0.1</h2>
        <ul>
            <li>Fixed error where <code>accessTheme</code> would sometimes be set to null (by first checking the value and deleting it if it is detected as null).</li>
            <li>Added a "Reset Theme" button in the theme settings that will revert/wipe all the theme settings. You need to click 6 times before it triggers (to ensure that it doesn't accidentally get triggered).</li>
            <li>Instead of prompting users to refresh the page after importing the theme settings, it will now automatically refresh the page.</li>
            <li>If <code>accessTheme</code> is disabled, the page will now refresh to compensate for an issue where the theme goes to light mode regardless of theme choice. Will see how this can be improved other ways.</li>
            <li>Fixed problem where <code>animationsEnabled</code> wasn't saved to local storage and wasn't included in the theme export system.</li>
            <li>Fixed problem where importing the wrong <code>.json</code> file in the import theme prompt would cause the entire site to error out.</li>
            <li>Added a temporary check if any of the affected theme values have a value of "undefined" and clears the value.</li>
        </ul>
    </div>
    <button class="collapsible">Update Log (1.0 to 2.0)</button>
    <div class="collapsible-content">
        <h2>Update 2.0</h2>
        <ul>
            <li>You will now be able to include multiple links within a tile. If you have a character that you use on multiple platforms, this should help reduce tile count.</li>
            <li>You are now able to edit the alt text for the tiles by going to the Edit Info section of a tile once it's been created.</li>
            <li>A new accessibility settings popup has been added where you can access all the accessibility-related options, including the color blindness options (previously in the theme settings).</li>
            <li>New "High Contrast Light Mode" and "High Contrast Dark Mode" have been added. These are modified versions of the Light Mode and AMOLED Mode with increased contrast.</li>
            <li>A new font selector tool has been added that allows you to change between the following fonts: Roboto, Open Sans, Lato, Montserrat, Poppins, Arial, Oswald, Slabo 27px, Source Sans Pro, Nunito, Merriweather, Dancing Script, Lora, Playfair Display, Raleway, Cabin, Rubik, Josefin Sans, Titillium Web, Bebas Neue, Cinzel, Anton, Fjalla One, Quicksand, Karla, Inconsolata, Varela Round, Coda, Zilla Slab, Noto Sans, Fira Sans, Roboto Condensed, Oxygen, Muli, Lobster, Amatic SC, Permanent Marker.</li>
            <li>A new font size increase and decrease button has been added that dynamically increases or decreases the size of the fonts.</li>
            <li>A new button allows you to disable the floating animations for the popups.</li>
            <li>When importing a file, if the import fails, the tile data currently on the website won't be affected (previously it would wipe the information).</li>
            <li>Cleaned up the CSS.</li>
          </ul> 
        <h2>Update 1.9.1</h2>
        <ul>
         <li>Fixed spelling error exlusively -> exclusively</li>
         <li>Fixed spelling error hyperlinkl -> hyperlink</li>
         <li>Fixed spelling error aobve -> above</li>
         <li>Export Theme now includes if tags were hidden or not</li>
         <li>Removed const value popupOverlay since it was never utilized</li>
         <li>Moved all the DOMContentLoaded to the bottom of the script section to make things slightly cleaner, more cleaning may come in the future</li>
         <li>Fixed height issues with the themes popup causing it to overflow on smaller screens (laptops and mobile devices.)</li>
         <li>Fixed edit URL section so that the secondary overlay won't appear unless the popup appears (aka if there's no text in the URL section it won't show up.)</li>
         <li>Fixed problems where the popup contents could be horizontally scrollable</li>
         <li>Fixed problem where the exit button for the random character popup would be cropped away</li>
     </ul>     
        <h2>Update 1.9</h2>
        <ul>
            <li>The ability to export and import the theme settings</li>
            <li>Updated the theme popup window to be better responsive on mobile devices</li>
            <li>Added two new buttons that will allow easier access to the re-ordering tool and merging tool</li>
            <li>Changed some things up to make UI more uniform</li>
            <li>Updated the information section to include new information about how to favourite characters</li>
            <li>🔞 now is an available tag for triggering the NSFW system.</li>
            <li>Similar to the favourites system, all the NSFW tags can be filtered with the NSFW option, though each one will still appear as their own separate tag in the dropdown.</li>
            <li>Duplicate tags on a tile will now be removed (so if you include "test" twice on a tag, it will remove one of them for example).</li>
            <li>When creating or editing links for a tile, if a duplicate link is found (already found in one of the tiles), it will prompt the user if they want to create a tile with a duplicate link.</li>
            <li>Like the ability to hide away the edit tile functions, you can hide the tags (they will still appear in the dropdown system).</li>
            <li>When uploading an image through a URL, you will now be prompted to preview the image before uploading it. This should help with ensuring that the image will successfully appear before it's added.</li>
        </ul>        
        <h2>Updpate 1.8</h2>
        <ul>
            <li>For the favourite tags, all will now appear under the ⭐ tag in the tag filtering dropdown.</li>
            <li>If there are no characters tagged as NSFW, the NSFW Inclusion prompt will not appear, allowing quicker access to the feature.</li>
            <li>If there are no characters that have NOT been tagged as NSFW, the NSFW Inclusion prompt will not appear, and <code>includeNSFW</code> will switch to true.</li>
            <li>Added an undo feature to remember the most recent deleted character, providing an opportunity to restore it.</li>
            <li>For Pinterest Extension users, the extension will no longer show up on the website, resolving issues with buttons covering site elements.</li>
            <li>Light Theme, Dark Mode, and AMOLED Mode buttons are now unified into a single button in the settings screen.</li>
            <li>You can now set the add-image tile to the beginning of the grid, while new tiles will still appear at the end.</li>
            <li>Fixed a bug where <code>.highlight</code> would not have a background color.</li>
        </ul>        
        <h2>Update 1.7.3</h2>
        <ul>
            <li>Added a new drop-down that will change the website's colors to make it more accessible for people with Deuteranopia, Protanopia, and Tritanopia.</li>
            <li>Added an AMOLED mode, which is a darker version of Dark Mode.</li>
            <li>Blur NSFW, Light Mode, Dark Mode, AMOLED Mode, and Color Blindness options are now combined into a new "Theme Settings" popup.</li>
            <li>The website will now remember if you had toggled to hide or show the tile buttons.</li>
            <li>The following emojis will now trigger the favorite character outline: ✨, 🌠, 🌟, 💫, 🤩, ❇️, ✴️, ✳️.</li>
            <li>Yaoi is now a trigger for the NSFW outline.</li>
            <li>Fixed issue where the overlay would continue to appear if you were to select exclude NSFW when there are no characters that don't have the NSFW tags.</li>
            <li>Updated the no non-NSFW character popup to include information about resetting the remembered state.</li>
          </ul>                 
        <h2>Update 1.7.2</h2>
        <ul>
            <li>Tag Filter dropdown now works on mobile</li>
            <li>For the share URL popup, the URL in the textbox should no longer be translated (resulting in it not appearing)</li>
            <li>Changed "Flush Remembered State" to "Reset Remembered State" since Flush didn't appear to translate correctly.</li>
            <li>Removed nsfw-preference-popup since it isn't used</li>
            <li>The buttons in the NSFW inclusion popup should now be centred</li>
            <li>Increased the size of the Select Image Source Popups on Mobile and Larger Screens</li>
            <li>Increased the spacing between certain buttons on mobile to make it more mobile responsive</li>
            <li>Increased the width of the Share URL buttons on larger screens</li>
            <li>The Copy URL button will no longer show a prompt that the url had been copied, it'll now appear as a console log (available through dev tools.)</li>
            <li>When curating a tile or editing the tags of an existing tile, if it includes both a trigger for the NSFW outline and Favourite Outline, it will now automatically switch it to the special outline instead of only applying after refresh</li>
            <li>When curating or editing a tile, all NSFW tag triggers should cause the outline to appear automatically instead of waiting for page refresh</li>
            <li>Changed the NSFW Outline, Favourite Outline, and Special Outline. They'll appear darker on light mode and lighter on dark mode. They also have a thicker outline to hopefully help make them more noticeable. Please tell me how you feel about the new colours.</li>
            <li>Added a new button that will allow you to toggle on/off the edit tags, edit info, edit image, and edit url buttons that appear on the tiles. The share tile button will still appear regardless.</li>
            <li>Forgot to include .cur and .jps and .jfif as supported file formats in 1.7 as I had originally indicated. They will now show as supported file types.</li>
        </ul>
        <h2>Update 1.7.1</h2>
        <ul>
            <li>Stated that the error where edit image url option was fixed in 1.7, apparently not. It should be fixed now though.</li>
        </ul>
        <h2>Update 1.7</h2>
        <ul>
            <li>Removed old depreciated functions that were replaced by newer functions (ones that used the prompt() system instead of the newer popup designs)</li>
            <li>Removed const values that were without usage: imageMethodPopup, popupContent, and deviceUploadBtn, and a duplicate urlUploadBtn</li>
            <li>When curating a tile, .jxl and .avif should now appear as available file formats when choosing to upload a local image (instead of having to select All Files.)</li>
            <li>.cur and .jps and .jfif support has been added</li>
            <li>The browser will now remember the "Remember my choice" button between refreshes instead of resetting each refresh (note this was an intentional function of the feature, not a bug.)</li>
            <li>A new "Flush Remembered State" button has been added which will allow you to reset the remembered state, showing you the NSFW inclusion/exclusion prompt when using the select random character feature.</li>
            <li>Fixed problem where the upload method popup would disappear as soon as the user selected the local option.</li>
            <li>Fixed problem where the input information section wouldn't disappear after the user curated an image.</li>
            <li>Fixed problem where the edit Image popup wouldn't disappear when submitting URL and further fixed problem where the overlay wouldn't disappear when cancelling the prompts.</li>
            <li>Fixed problem where the edit image url option wouldn't work</li>
        </ul>
        
        <h2>Update 1.6</h2>
        <ul>
            <li>Fixed error where clicking outside the popup window would cause select random character popup to not appear afterwards until refresh</li>
            <li>A new section bellow the description blurb that allows you to read all the updates</li>
            <li>The random character popup should now be more responsive for mobile devices/small screens</li>
            <li>The width of the popup should now stay consistent regardless of how much information is included for them (previously characters with less information would have shorter info boxes, causing some things to shift around.)</li>
            <li>The new triggers for the NSFW system now apply to the merger website. You will now be prompted to remove NSFW characters if they have the new tags that indicate it as being NSFW.</li>
            <li>Updated the invalid links system for the merger website to ensure that the linked website in the url section of a tile is an actual website. It does this by checking if http: or https: is included and checks if theres any periods that would imply a TLD is included (since smth like https://test/ wont lead to a website.)</li>
            <li>Added Manual Up and Down buttons on the Reordering Website that will move the tile up or down one position</li>
            <li>Added the ability to upload images either by locally uploading an image (the previous exclusive method) or by providing a web URL.</li>
            <li>When the NSFW inclusion prompt is shown, you will be prompted to either have it remember or not remember via a checkbox. Note that on refresh the state will return to unchecked.</li>
        </ul>
       <h2>Update 1.5.1</h2>
       <ul>
          <li>Modifications to the Bookmarking website, Merge Tool and Reordering Tool to make the websites more responsive on mobile/smaller devices. Note that update 1.6 will bring further improvements to this.</li>
       </ul>
       <h2>Update 1.5</h2>
       <ul>
          <li>With the reordering tool, you can now sort between the following options</li>
          <ul>
             <li>Name Alphabetically (A -> Z) and Reverse Alphabetically (Z -> A)</li>
             <li>Age by Oldest to Youngest and Youngest to Oldest</li>
             <li>Platform Name Alphabetically and Reverse Alphabetically</li>
          </ul>
          <li>Made changes to the special outline trigger to make it appear more consistently.</li>
          <ul>
             <li>Note if you're importing tiles that would have the special outline applied, you need to refresh the page before the outlines apply</li>
          </ul>
          <li>Favourite and Special Outline now Appear on the Random Character Popout Alongside the NSFW Outline</li>
          <li>FavIcons have been added to the three pages to make it easier to see which page is what</li>
          <li>Added "NSFW", "Hentai", and "Porn" as tags that will trigger the NSFW Outline</li>
          <li>.avif and .jxl are now listed as supported files</li>
          <li>Curated a new information blurb and made it collapseable</li>
          <li>When trying to use the Random Character feature, you'll be prompted if you want to include NSFW characters</li>
          <li>When the Random Character Popup is Opened, instead of having to click the Random Character button over and over (which would now show the prompt each time) you can press a reroll button to show a new character</li>
          <li>Updated the File Upload System, Edit URL System, Edit Tag System, Edit Info System and Copy URL System from the previous prompt() system to a popup system to keep the design consistent</li>
          <li>When opening a popup, an overlay blur will now appear behind the popup. Clicking the overlay will cause the current popup to close. This should prevent the openning of multiple popups at once alongside giving users a more convient way to close the popups</li>
       </ul>
       <h2>Update 1.4 (dont ask what happened to update 1.3)</h2>
       <ul>
          <li>Blur NSFW Option Now Applies to the Random Character Feature if an 18+ character is selected</li>
          <li>Updated Styling of the Random Character Feature</li>
          <li>Edit URL and Edit Photo are now to SEPERATE buttons</li>
          <li>Edit Info Button has been added that allows you to specify information relating to the character like the characters name, age, description and which platform they're available on. This information will appear when it is selected in the random character feature.</li>
          <li>Adding ⭐ Will Indicate it as a "Favourite" and curate a special outline for it</li>
          <li>Adding the 18+ will outline the tile and popup if its selected from the random character feature</li>
          <li>Changed some colours for accessibility</li>
          <li>New Merger Tool</li>
          <ul>
             <li>Merge Two Backups Together</li>
             <li>Automatically removes duplicate characters (by their hyperlink/url)</li>
             <li>Prompt to remove NSFW characters when merging files</li>
             <li>Prompt to remove characters with "https://" as their hyperlink</li>
          </ul>
          <li>Reordering Tool</li>
          <ul>
             <li>Allows you to reorder tiles</li>
          </ul>
       </ul>
       <h2>Update 1.2</h2>
       <ul>
          <li>Added a new system that will blur tiles that have 18+ as a tag.</li>
          <li>Changed edit image function to request a local image instead of a URL</li>
          <li>Hover colours for buttons and tags to make it more visible if you're hovering over them</li>
          <li>Description blurb on how to use the tool</li>
          <li>Changed the name of the tab and the header to Character Bookmarking Tool</li>
       </ul>
    </div>
    <div class="controls">
       <div class="theme-toggle">
          <button id="settings-btn2" style="padding:15px">Settings</button>
          <button id="settings-btn">Theme Settings</button>
          <button id="acccessibility-btn">Accessibility Settings</button>
          <button id="random-character-btn">Select Random Character</button>
          <button id="openReorderToolButton">Open Reorder Tool</button>
          <button id="openBackupMergeButton">Open Backup Merge</button>
          <select id="tag-filter-mobile">
             <option value="all">All Tags</option>
          </select>
       </div>
       <div class="controls">
          <select id="tag-filter">
             <option value="all">All Tags</option>
          </select>
       </div>
    </div>
    <!-- Popup Structure -->
    <div id="character-popup" class="popup hidden">
        <img id="popup-image" src="" alt="Character Image">
        <span id="popup-close">&times;</span>
        <div class="popup-info">
            <h3 id="popup-name"></h3>
            <p id="popup-platform"></p>
            <p id="popup-age"></p>
            <p id="popup-description"></p>
            <div id="popup-custom-fields"></div>
            <p id="popup-tags"></p>
        </div>
        <button id="popup-button" type="button">View Profile</button>
        <button id="reroll-btn">Reroll</button>
        <button id="popup-close-btn">Close</button>
    </div>
    <div id="settings-popout" class="popup">
    <h3>Settings</h3>
    <div class="button-container">
        <button id="export-btn">Export Tiles</button>
        <button id="import-btn">Import Tiles</button>
    </div>
    <button id="optToggleButton" style="padding:15px">Opt-Out of Reminders</button>
    <button id="flush-button">Reset Remembered State</button>     
    <button id="settings-btn1" style="padding:15px">Theme Settings</button>
    <button id="acccessibility-btn1" style="padding:15px">Accessibility Settings</button>
    </div>    
    <!--Tile Creation Popup-->
    <div id="tile-creation-popup">
       <h3>Create New Tile</h3>
       <input type="text" id="tile-link" placeholder="Enter a link for this image">
       <input type="text" id="tile-tags" placeholder="Enter tags separated by commas">
       <input type="text" id="tile-name" placeholder="Enter character name">
       <input type="text" id="tile-platform" placeholder="Enter platform">
       <input type="text" id="tile-age" placeholder="Enter age">
       <textarea id="tile-description" placeholder="Enter description"></textarea>
       <button id="create-tile-btn">Create Tile</button>
       <button id="cancel-tile-btn">Cancel</button>
    </div>
    <!--Edit URL Popup-->
    <div id="edit-url-popup" class="edit-popup">
        <h3>Edit URL</h3>
            <input type="text" id="edit-url-input" placeholder="Enter new URL">
        <button id="save-url-btn">Save</button>
        <button id="cancel-url-btn">Cancel</button>
     </div>     
    <!--Edit Info Popup-->
    <div id="edit-info-popup" class="edit-popup">
        <h3>Edit Info</h3>
        <div id="default-fields" style="width:100%">
            <div style="width:100%">
                <span class="input-label">Character Name:</span>
                <input type="text" id="edit-name-input" placeholder="Enter character name">
            </div>
            <div style="width:100%">
                <span class="input-label">Platform:</span>
                <input type="text" id="edit-platform-input" placeholder="Enter platform">
            </div>
            <div style="width:100%">
                <span class="input-label">Age:</span>
                <input type="text" id="edit-age-input" placeholder="Enter age">
            </div>
            <div style="width:100%">
                <span class="input-label">Description:</span>
                <textarea id="edit-description-input" placeholder="Enter description"></textarea>
            </div>
            <div style="width:100%">
                <span class="input-label">Alt Text:</span>
                <input type="text" id="edit-alt-input" placeholder="Enter alt text">
            </div>
        </div>
        <div id="custom-fields" style="margin-top: 10px"></div>
        <button id="add-custom-field-btn">Add Custom Field</button>
        <div style="width:100%">
            <button id="show-formatting guide">Formatting Guide</button>
            <button id="save-info-btn">Save</button>
            <button id="cancel-info-btn">Cancel</button>
        </div>
    </div>
    <div id="formatting-guide" style="overflow-y: auto;  max-height: 80vh;">
    <h2>Formatting Guide</h2>
    <button id="close-formatting">Close</button>
    <p>When editing custom values, you will have access to formatting tools which change the apperance of the text when it appears on the random character popup.</p>
    <h3>Creating Unordered Lists</h3>
    <p>You can create an ordered list by adding (-) to the beginning of a line or by pressing Ctrl + -</p>
    <p>Note that nested lists aren't supported.</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_UnOrderedList.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Creating Ordered Lists</h3>
    <p>You can create an unordered list by adding (#) to the beginning of a line or by pressing Ctrl + Shift + #</p>
    <p>Note that nested lists aren't supported.</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_OrderedList.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Indents</h3>
    <p>You can add indents to text by adding (ind) anywhere within the text. It will add a couple of lines between the text that surrounds it. Placement doesn't matter and can also be added by pressing Ctrl + Shift + | (the button with \|)</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Indent.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Bold</h3>
    <p>You can <b>bold text</b> by adding (b)(/b) or highlighting the text you want bolded and pressing Ctrl + B</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Bold.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Italics</h3>
    <p>You can add <i>italics</i> to text by adding (i)(/i) or highlighting the text you want italicized and pressing Ctrl + I</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Italics.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Underline</h3>
    <p>You can add <u>underlines</u> to text by adding (u)(/u) or highlighting the text you want underlined and pressing Ctrl + U</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Underline.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Strikethrough</h3>
    <p>You can add <s>strikethrough</s> to text by adding (s)(/s) or higlighting the text you want to have strikethrough and pressing Ctrl + S</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_StrikeThrough.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Inline Code</h3>
    <p>You can add <code>inline code</code> to text by adding (c)(/c) or higlighting the text you want to be inline code and pressing Ctrl + K</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_InlineCode.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Blockquote</h3>
    <p>You can make text a blockquote by adding (q)(/q) or higlighting the text you want to be a blockquote and pressing Ctrl + Q</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Blockquote.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Subscript</h3>
    <p>You can make text subscript by adding (sub)(/sub) or highlighting the text you want to be subscript and pressing Ctrl + =</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Subscript.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Superscript</h3>
    <p>You can make text superscript by adding (sup)(/sup) or higlighting the text you want to be superscript and pressing Ctrl + Shift + =</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Supperscript.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Blur Text</h3>
    <p>You can add a blur to text by adding (blur)(/blur). Hovering over the blurred text will unblur it untill its not hovered over</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_BlurredBlurred.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_BlurredUnBlurred.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Letterspace</h3>
    <p>Letterspace increaes the space between the letters and can be added by using (letterspace="")(/letterspace) with the value being {num}px</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Letterspacing.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Text Color</h3>
    <p>This allows you to change the colour of the text that its surrounding and can be added by using (color="{color}")(/color)</p>
    <p>The colour value can either be the colour name (red), the hex value (#FF0000), the rgb value (rgb(255,0,0)) or hsl value (hsl(0, 100%, 50%))</p>
    <p>Note make sure you use 'color' and NOT 'colour' as the latter wont work (CSS doesn't accept 'colour' as an acceptable parameter)</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_TextColor.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Background Color</h3>
    <p>This allows you to change the colour of the background behind the text</p>
    <p>The colour value can either be the colour name (red), the hex value (#FF0000), the rgb value (rgb(255,0,0)) or hsl value (hsl(0, 100%, 50%))</p>
    <p>Note make sure you use 'color' and NOT 'colour' as the latter wont work (CSS doesn't accept 'colour' as an acceptable parameter)</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_BackgroundColor.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    <h3>Hyperlinks</h3>
    <p>This allows you to turn the text into a hyperlink and can be added by using (link="{hyperlink}")(/link)</p>
    <img src="https://raw.githubusercontent.com/ThatOneUnoriginal/ThatOneUnoriginal.github.io/refs/heads/main/Character%20Tools/Assets/CharacterFormatting_Hyperlink.png" style="max-width: 100%; height: auto; min-height:0%; object-fit: contain">
    </div>
    <!--Edit Tags Popup-->
    <div id="edit-tags-popup" class="edit-popup">
       <h3>Edit Tags</h3>
       <input type="text" id="edit-tags-input" placeholder="Enter tags separated by commas">
       <button id="save-tags-btn">Save</button>
       <button id="cancel-tags-btn">Cancel</button>
    </div>
    <!--Share URL Popup-->
    <div id="share-url-popup">
       <h3>Share URL</h3>
       <input type="text" id="share-url-input" class="notranslate" readonly>
       <button id="copy-url-btn">Copy URL</button>
       <button id="close-share-url-btn">Close</button>
    </div>
    <!-- NSFW Inclusion Popup -->
    <div id="nsfw-inclusion-popup">
        <h3>Include NSFW Characters?</h3>
        <p>Do you want to include NSFW characters in the random selection?</p>
            <button id="include-nsfw-btn">Yes, Include NSFW</button>
            <button id="exclude-nsfw-btn">No, Exclude NSFW</button>
        <label>
            <input type="checkbox" id="remember-nsfw-state-checkbox"> Remember my choice</input>
        </label>
    </div>  
    <!-- Settings Popup -->
    <div id="settings-popup" style="overflow-y: auto;">
        <h3>Theme Settings</h3>
            <button id="blur-nsfw-btn">Blur NSFW</button>
            <button id="theme-toggle-btn">Light Mode</button>
            <div class="button-container">
                <button id="hide-tags-button">Hide Tags</button>
                <button id="toggleButton">Hide Tile Buttons</button>
            </div>
            <button id="toggle-position-btn">Move Add Image to Beginning</button>
            <select id="tileSize">
                <option value="small">Small Tiles</option>
                <option value="medium" selected>Medium Tiles</option>
                <option value="large">Large Tiles</option>
            </select>
            <div class="button-container">
            <button id="exportButton">Export Theme Settings</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" />
            <button id="importButton">Import Theme Settings</button>
            </div>
            <button id="reset-theme-btn">Reset Theme (6 clicks needed)</button>
            <button id="settings-close">Close</button>
    </div>    
    <div id="accessibility-popup" style="overflow-y: auto;">
        <h3>Accessibility Settings</h3>
        <button id="toggle-animations">Toggle Animations On</button>
        <div class="button-container">
            <button id="increase-weight">Increase Font Weight</button>
            <button id="decrease-weight">Decrease Font Weight</button>           
        </div>
        <div class="button-container">
            <button id="increase-font-btn">Increase Font Size</button>
            <button id="decrease-font-btn">Decrease Font Size</button>
        </div>
        <div class="button-container">
            <button id="increase-margin">Increase Veritical Margin</button>
            <button id="decrease-margin">Decrease Veritical Margin</button>
        </div>        
        <button id="force-mobile-buttons">Force Mobile Buttons</button>
        <select id="font-dropdown">
            <option value="" disabled selected>Select a font</option>
            <option value="Roboto">Roboto</option>
            <option value="Open Sans">Open Sans</option>
            <option value="Lato">Lato</option>
            <option value="Montserrat">Montserrat</option>
            <option value="Poppins">Poppins</option>
            <option value="Arial">Arial</option>
            <option value="Oswald">Oswald</option>
            <option value="Slabo 27px">Slabo 27px</option>
            <option value="Source Sans Pro">Source Sans Pro</option>
            <option value="Nunito">Nunito</option>
            <option value="Merriweather">Merriweather</option>
            <option value="Dancing Script">Dancing Script</option>
            <option value="Lora">Lora</option>
            <option value="Playfair Display">Playfair Display</option>
            <option value="Raleway">Raleway</option>
            <option value="Cabin">Cabin</option>
            <option value="Rubik">Rubik</option>
            <option value="Josefin Sans">Josefin Sans</option>
            <option value="Titillium Web">Titillium Web</option>
            <option value="Bebas Neue">Bebas Neue</option>
            <option value="Cinzel">Cinzel</option>
            <option value="Anton">Anton</option>
            <option value="Fjalla One">Fjalla One</option>
            <option value="Quicksand">Quicksand</option>
            <option value="Karla">Karla</option>
            <option value="Inconsolata">Inconsolata</option>
            <option value="Varela Round">Varela Round</option>
            <option value="Coda">Coda</option>
            <option value="Zilla Slab">Zilla Slab</option>
            <option value="Noto Sans">Noto Sans</option>
            <option value="Fira Sans">Fira Sans</option>
            <option value="Roboto Condensed">Roboto Condensed</option>
            <option value="Oxygen">Oxygen</option>
            <option value="Muli">Muli</option>
            <option value="Lobster">Lobster</option>
            <option value="Amatic SC">Amatic SC</option>
            <option value="Permanent Marker">Permanent Marker</option>
        </select>         
        <select id="theme-dropdown-accessibility">
            <option value="disabled">High Contrast Theme Disable</option>
            <option value="high-contrast-dark">High Contrast Dark</option>
            <option value="high-contrast-light">High Contrast Light</option>
        </select>        
        <select id="colorSelector">
            <option value="original">Original</option>
            <option value="colour1">Deuteranopia</option>
            <option value="colour2">Protanopia</option>
            <option value="colour3">Tritanopia</option> 
        </select>   
        <button id="accessibility-settings-close">Close</button>       
    </div>
    <div id="image-popup" class="popup hidden">
          <h3>Select Image Source</h3>
          <button id="local-upload-btn">Upload from Device</button>
          <button id="url-upload-btn">Provide Image URL</button>
          <button id="url-popup-close">Close</button>
    </div>
    <div id="image-source-popup" class="popup hidden">
        <h2>Select Image Source</h2>
        <button id="local-image-btn">Upload from Device</button>
        <button id="url-image-btn">Provide URL</button>
        <button id="urlURL-popup-close">Close</button>
    </div>
    <div id="image-confirmation-popup" class="popup hidden">
            <img id="preview-image" src="" alt="Image Preview">
            <p>Does this image look correct?</p>
            <button id="confirm-image-btn">Yes</button>
            <button id="cancel-image-btn">No</button>
    </div>    

    <div id="new-image-confirmation-popup" class="popup hidden">
            <img id="new-preview-image" src="" alt="Image Preview">
            <p>Does this image look correct?</p>
            <button id="new-confirm-image-btn">Yes</button>
            <button id="new-cancel-image-btn">No</button>
    </div>
    
    <!-- Add this HTML for the URL input popup -->
    <div id="url-input-popup" class="popup hidden">
        <h2>Enter Image URL</h2>
        <input type="text" id="image-url-input" placeholder="Enter image URL">
        <button id="submit-url-btn">Submit</button>
        <button id="url-popup-close-url1">Close</button>
    </div>
    <div id="url-popup" class="popup hidden">
           <h3>Enter Image URL</h3>
           <input type="text" id="image-url-input1" placeholder="Paste image URL here" />
           <button id="submit-url-btn1">Submit</button>
           <button id="url-popup-close-url">Close</button>
     </div>
    <!-- Image Selection Prompt -->
    <div id="image-method-popup" class="popup hidden">
          <h2>Select Image Source</h2>
          <button id="local-image-btn">Upload Local Image</button>
          <button id="url-image-btn">Use Image URL</button>
          <button id="cancel-image-selection">Cancel</button>
    </div>
    <div id="undo-delete-popup">
  <p>Tile deleted. <span id="undo-timer">30</span>s</p>
  <div>
    <button id="undo-delete-btn">Undo</button>
    <button id="dismiss-undo">✕</button>
    </div>
</div>

<div id="crop-image-popup" class="popup hidden">
        <img id="full-image" src="" alt="Full Image" style="max-width: 100%; position: relative;">
        <div id="crop-area" style="position: absolute; border: 2px dashed #fff; background-color: rgba(255, 255, 255, 0.5);"></div>
        <button id="confirm-crop-btn">Confirm Crop</button>
        <button id="cancel-crop-btn">Cancel</button>
</div>

    <!-- Add the file input for uploading images -->
    <input type="file" id="file-input" accept="image/*,.avif,.jxl,.cur,.jps,.jfif" class="hidden">
    <div class="image-grid" id="image-grid">
       <div class="image-item add-image" id="add-image">
          +
       </div>
    </div>
    <input type="file" id="file-input" accept="image/*,.avif,.jxl,.cur,.jps,.jfif">
    <input type="file" id="import-file-input" accept="application/json">
    <div id="popup-overlay" class="popup-overlay"></div>
    <div id="popup-overlay1" class="popup-overlay1"></div>
    <script>
const imageGrid = document.getElementById('image-grid');
const addImageButton = document.getElementById('add-image');
const fileInput = document.getElementById('file-input');
const tagFilter = document.getElementById('tag-filter') ;
const tagFilterMobile = document.getElementById('tag-filter-mobile');
const exportBtn = document.getElementById('export-btn');
const importBtn = document.getElementById('import-btn');
const importFileInput = document.getElementById('import-file-input');
const blurNSFWBtn = document.getElementById('blur-nsfw-btn');
const imageUploadChoicePopup = document.getElementById('image-upload-choice-popup');
const urlUploadBtn = document.getElementById('url-upload-btn');
const addImageTile = document.getElementById('add-image');
const togglePositionBtn = document.getElementById('toggle-position-btn');
const undoPopup = document.getElementById('undo-delete-popup');
const undoButton = document.getElementById('undo-delete-btn');
const dismissButton = document.getElementById('dismiss-undo');
const timerSpan = document.getElementById('undo-timer');
const tileSizeSelector = document.getElementById('tileSize');
const starTags = ['⭐', '🌟', '✨', '🌠', '💫', '🤩', '❇️', '✴️', '✳️'];
const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; 
const hideTagsButton = document.getElementById("hide-tags-button");
const tags = document.querySelectorAll(".tag");
const resetButton = document.getElementById('reset-theme-btn');
const settingsClose = document.getElementById('settings-close');
const popupOverlay = document.getElementById('popup-overlay');

let tagsVisible = true;
let clickCount = 0;



function resetClickCounter() {
    clickCount = 0;
    resetButton.textContent = 'Reset Theme (6 clicks needed)';
}

resetButton.addEventListener('click', function() {
    clickCount++;

    if (clickCount < 6) {
        resetButton.textContent = `Reset Theme (${6 - clickCount} clicks needed)`;
    } else {
        // Clear the specified local storage items
        localStorage.removeItem('theme');
        localStorage.removeItem('isBlurred');
        localStorage.removeItem('tagsVisible');
        localStorage.removeItem('buttonsHidden');
        localStorage.removeItem('addImagePosition');
        localStorage.removeItem('tileSize');
        localStorage.removeItem('fontweightindex');
        localStorage.removeItem('selectedFont');
        localStorage.removeItem('accessTheme');
        localStorage.removeItem('selectedColorOption');
        localStorage.removeItem('animationsEnabled');
        localStorage.removeItem('forceMobileButtons')

        // Set fontSize to 16
        localStorage.setItem('fontSize', 16);
        localStorage.setItem('marginValue', 10)

        window.location.reload();
    }
});



// Reset counter when "settings-close" or "popup-overlay" are clicked
settingsClose.addEventListener('click', resetClickCounter);
popupOverlay.addEventListener('click', resetClickCounter);
// Load the visibility state from local storage on page load
window.addEventListener('load', function() {
    const storedVisibility = localStorage.getItem('tagsVisible');
    if (storedVisibility !== null) {
        tagsVisible = storedVisibility === 'true'; // Convert string to boolean
    }
    updateTagVisibility(tagsVisible);
});

hideTagsButton.addEventListener('click', function() {
    tagsVisible = !tagsVisible; // Toggle visibility
    updateTagVisibility(tagsVisible);
    
    // Save the visibility state in local storage
    localStorage.setItem('tagsVisible', tagsVisible);
});

function updateTagVisibility(visible) {
    const tags = document.querySelectorAll('.tag');
    tags.forEach(tag => {
        tag.style.display = visible ? 'block' : 'none'; // Show or hide the tag
    });

    // Change the button text based on the tags' state
    hideTagsButton.textContent = visible ? 'Hide Tags' : 'Show Tags';
}

// Initialize tag visibility based on the stored state
updateTagVisibility(tagsVisible);


let tiles = [];
let allTags = new Set();
let isBlurred = false; // Load blur status from localStorage
let rememberNSFWChoice = JSON.parse(localStorage.getItem('rememberNSFWChoice')) || false;
let includeNSFW = JSON.parse(localStorage.getItem('includeNSFW')) || false;
let deletedTilesQueue = [];
let undoTimer = null;

let isAtEnd =  true;  // Initially, the add-image tile is at the end
let marginValue = parseInt(localStorage.getItem('marginValue')) || 10; // Get margin from local storage or set default

// Function to update margin-bottom for specified elements
function updateMargin() {
    const elements = document.querySelectorAll(`
        .cancelButtonXyZwv,
        .compressionButtonQwErAs,
        .resizeButtonRtYuIo,
        .buttonHgFdSa,
        .theme-toggle button,
        #tag-filter,
        #tag-filter-mobile,
        #export-btn,
        #import-btn,
        #tile-size,
        #colorSelector,
        #popup-button,
        #reroll-btn,
        #local-upload-btn,
        #url-upload-btn,
        #url-popup-close,
        #url-popup-close-url,
        #local-image-btn,
        #url-image-btn,
        #urlURL-popup-close,
        #url-popup-close-url1,
        #popup-close,
        .collapsible,
        .edit-popup button,
        #submit-url-btn,
        #submit-url-btn1,
        #share-url-popup button,
        #nsfw-inclusion-popup button,
        #image-upload-choice-popup button,
        #tile-creation-popup button,
        #settings-popup button,
        #tileSize,
        #undo-delete-popup button,
        #popup-close-btn,
        #new-confirm-image-btn,
        #confirm-image-btn,
        #new-cancel-image-btn,
        #cancel-image-btn,
        #image-confirmation-popup button,
        #new-image-confirmation-popup button,
        .link-button,
        #close-links-popup,
        #accessibility-popup button,
        #theme-dropdown-accessibility,
        #close-multi-links-popup,
        #font-dropdown,
        #close-formatting
    `); // Select all specified elements
    
    elements.forEach(element => {
        element.style.marginBottom = `${marginValue}px`;
    });
    
    // Save the current margin value to local storage
    localStorage.setItem('marginValue', marginValue);
}

document.getElementById('increase-margin').addEventListener('click', () => {
    marginValue += 5; // Increase margin by 5 pixels
    updateMargin();
});

// Assuming marginValue is defined somewhere in your code
// Assuming marginValue is defined somewhere in your code
document.getElementById('decrease-margin').addEventListener('click', () => {
    // Define minimum padding values
    const minimumPaddingGeneral = 15; // General minimum padding value
    const minimumPaddingExceptions = 10; // Minimum for specific exceptions

    // Define the elements with exceptions
    const exceptionSelectors = [
        '#nsfw-inclusion-popup button',
        '#settings-popup button',
        '#colorSelector',
        '#tileSize',
        '#accessibility-popup button',
        '#theme-dropdown-accessibility',
        '#font-dropdown'
    ];

    // Determine if the marginValue belongs to an exception
    const isException = exceptionSelectors.some(selector => {
        const elements = document.querySelectorAll(selector);
        return Array.from(elements).some(element => element.contains(event.target));
    });

    // Adjust marginValue based on whether it's an exception or not
    if (isException) {
        marginValue = Math.max(minimumPaddingExceptions, marginValue - 5); // Prevent margin from going below 10
    } else {
        marginValue = Math.max(minimumPaddingGeneral, marginValue - 5); // Prevent margin from going below 15
    }

    updateMargin();
});



// Initialize margin on page load
updateMargin();


// Function to check and clear accessTheme if it's "null"
function checkAndClearAccessTheme() {
    // Retrieve the accessTheme value from local storage
    const accessTheme = localStorage.getItem('accessTheme');
    
    // Check if accessTheme is "null"
    if (accessTheme === "null") {
        // Remove accessTheme from local storage
        localStorage.removeItem('accessTheme');
        console.log("accessTheme was 'null' and has been cleared.");
    }
}

// Call the function on page load or when needed
checkAndClearAccessTheme();


document.getElementById('openReorderToolButton').addEventListener('click', function() {
        window.open('https://thatoneunoriginal.github.io/reorder%20tool.html', '_blank');
    });

    document.getElementById('openBackupMergeButton').addEventListener('click', function() {
        window.open('https://thatoneunoriginal.github.io/backup%20merge.html', '_blank');
    });

    document.getElementById('exportButton').addEventListener('click', () => {
    // Retrieve values from local storage, defaulting to an empty string if not present
    const settings = {
        isBlurred: localStorage.getItem('isBlurred') || "",
        theme: localStorage.getItem('theme') || "",
        addImagePosition: localStorage.getItem('addImagePosition') || "",
        selectedColorOption: localStorage.getItem('selectedColorOption') || "",
        tileSize: localStorage.getItem('tileSize') || "",
        tagsVisible: localStorage.getItem('tagsVisible') || "",
        fontSize: localStorage.getItem('fontSize') || "",
        fontweightindex: localStorage.getItem('fontweightindex') || "", // Corrected from 'font-weight-index'
        accessTheme: localStorage.getItem('accessTheme') || "",
        selectedFont: localStorage.getItem('selectedFont') || "",
        animationsEnabled: localStorage.getItem('animationsEnabled') || "",
        marginValue: localStorage.getItem('marginValue') || "",
        forceMobileButtons: localStorage.getItem('forceMobileButtons') || "",
    };

    // Convert settings to a JSON string
    const settingsJSON = JSON.stringify(settings, null, 2);

    // Create a Blob object to facilitate download
    const blob = new Blob([settingsJSON], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    // Create a temporary link element for downloading
    const a = document.createElement('a');
    a.href = url;
    a.download = 'settings.json'; // Filename for the downloaded file
    document.body.appendChild(a);
    a.click(); // Trigger the download
    document.body.removeChild(a); // Clean up

    // Release the blob URL
    URL.revokeObjectURL(url);
});


const elementsToAdjust = document.querySelectorAll(
    'h2, li, p, .theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #settings-btn1, #flush-button, #optToggleButton, #settings-btn2, #acccessibility-btn1, #import-btn, #tile-size, #colorSelector, #popup-button, #reroll-btn, #local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #url-image-btn, #urlURL-popup-close, #url-popup-close-url1, #popup-close, .collapsible, .edit-popup button, #submit-url-btn, #submit-url-btn1, #share-url-popup button, #nsfw-inclusion-popup button, #image-upload-choice-popup button, #tile-creation-popup button, #settings-popup button, #tileSize, #undo-delete-popup button, #popup-close-btn, #new-confirm-image-btn, #confirm-image-btn, #new-cancel-image-btn, #cancel-image-btn, #image-confirmation-popup button, #new-image-confirmation-popup button, .link-button, #close-links-popup, #accessibility-popup button, #theme-dropdown-accessibility, #close-multi-links-popup, #font-dropdown'
);

let currentFontSize = localStorage.getItem('fontSize') ? parseInt(localStorage.getItem('fontSize')) : 16; // Load from local storage or default to 16

// Apply the saved font size on page load
adjustFontSize(currentFontSize);

document.getElementById('increase-font-btn').addEventListener('click', () => {
    currentFontSize += 2; // Increase by 2 pixels
    adjustFontSize(currentFontSize);
});

document.getElementById('decrease-font-btn').addEventListener('click', () => {
    if (currentFontSize > 10) { // Prevent font size from going below 10 pixels
        currentFontSize -= 2; // Decrease by 2 pixels
        adjustFontSize(currentFontSize);
    }
});

function adjustFontSize(size) {
    // Adjust font size for all elements
    elementsToAdjust.forEach(element => {
        element.style.fontSize = size + 'px';
    });

    // Dynamically update the CSS for the "test" class with !important
    const styleElement = document.getElementById('dynamic-style') || document.createElement('style');
    styleElement.id = 'dynamic-style';
    styleElement.innerHTML = `.test { font-size: ${size}px !important; }`;

    document.head.appendChild(styleElement); // Ensure it is added to the document

    localStorage.setItem('fontSize', size); // Save the current font size to local storage
}






document.getElementById('importButton').addEventListener('click', () => {
    const fileInput = document.getElementById('importFile');
    fileInput.click(); // Programmatically click the file input

    // Add an event listener for when a file is selected
    fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];

        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const settings = JSON.parse(event.target.result);
                    
                    // Apply settings to local storage with default values if not present
                    localStorage.setItem('isBlurred', settings.isBlurred || "");
                    localStorage.setItem('theme', settings.theme || "");
                    localStorage.setItem('addImagePosition', settings.addImagePosition || "");
                    localStorage.setItem('selectedColorOption', settings.selectedColorOption || "");
                    localStorage.setItem('tileSize', settings.tileSize || "");
                    localStorage.setItem('tagsVisible', settings.tagsVisible || "");
                    localStorage.setItem('fontSize', settings.fontSize || ""); // Set to "" if not a number
                    localStorage.setItem('fontweightindex', settings.fontweightindex || ""); // Set to "" if not a number
                    localStorage.setItem('accessTheme', settings.accessTheme || "");
                    localStorage.setItem('selectedFont', settings.selectedFont || "");
                    localStorage.setItem('animationsEnabled', settings.animationsEnabled || "");
                    localStorage.setItem('marginValue', settings.marginValue || "");
                    localStorage.setItem('forceMobileButtons', settings.forceMobileButtons || "");
                    window.location.reload(); // Reload page after applying settings
                } catch (error) {
                    alert('Failed to import settings: ' + error.message);
                }
            };

            reader.readAsText(file);
        } else {
            alert('No file selected.');
        }
    }, { once: true }); // Ensure the listener is only added once
});



// Function to toggle the position of the add-image tile
function toggleAddImagePosition() {
    if (isAtEnd) {
        // Move to the beginning (before the first non-add-image tile, if any)
        imageGrid.insertBefore(addImageTile, imageGrid.firstElementChild);
        togglePositionBtn.textContent = 'Move Add Image to End';
        localStorage.setItem('addImagePosition', 'beginning');
    } else {
        // Move to the end
        imageGrid.appendChild(addImageTile);
        togglePositionBtn.textContent = 'Move Add Image to Beginning';
        localStorage.setItem('addImagePosition', 'end');
    }
    isAtEnd = !isAtEnd;  // Toggle the state
}

// Function to apply the saved position on page load
function applySavedPosition() {
    const savedPosition = localStorage.getItem('addImagePosition');
    if (savedPosition === 'beginning') {
        // Move to the beginning (before the first tile in the grid)
        imageGrid.insertBefore(addImageTile, imageGrid.firstElementChild);
        togglePositionBtn.textContent = 'Move Add Image to End';
        isAtEnd = false;
    } else {
        // Move to the end by default
        imageGrid.appendChild(addImageTile);
        togglePositionBtn.textContent = 'Move Add Image to Beginning';
        isAtEnd = true;
    }
}

// Add event listener to the button
togglePositionBtn.addEventListener('click', toggleAddImagePosition);


// Function to set the tile size
function setTileSize(size) {
    let sizeValue;
    switch (size) {
        case 'small':
            sizeValue = '150px';
            break;
        case 'medium':
            sizeValue = '200px';
            break;
        case 'large':
            sizeValue = '250px';
            break;
        default:
            sizeValue = '200px'; // default to medium if nothing is found
    }
    imageGrid.style.setProperty('--tile-size', sizeValue);
}







// Save the tile size to local storage when the user changes it
tileSizeSelector.addEventListener('change', function() {
    const selectedSize = this.value;
    localStorage.setItem('tileSize', selectedSize); // Save the selected size
    setTileSize(selectedSize); // Apply the new size to the grid
});

function showUndoPopup() {
  undoPopup.classList.add('show');
  let secondsLeft = 30;
  timerSpan.textContent = secondsLeft;

  // Clear any existing timer before starting a new one
  if (undoTimer) {
    clearInterval(undoTimer);
  }

  undoTimer = setInterval(() => {
    secondsLeft--;
    timerSpan.textContent = secondsLeft;

    if (secondsLeft <= 0) {
      hideUndoPopup();
    }
  }, 1000);
}

function hideUndoPopup() {
  clearInterval(undoTimer);
  undoPopup.classList.remove('show');
  deletedTile = null;
}
function applyDynamicButtonColors(button) {
   const selectedColorOption = localStorage.getItem('selectedColorOption') || 'original';
   const buttonColors = [
      'var(--button-bg-1)', 
      'var(--button-bg-2)', 
      'var(--button-bg-3)', 
      'var(--button-bg-4)'
   ];
   const buttonHoverColors = [
      'var(--button-bg-hover-1)', 
      'var(--button-bg-hover-2)', 
      'var(--button-bg-hover-3)', 
      'var(--button-bg-hover-4)'
   ];
   
   const selectedIndex = selectedColorOption === 'original' ? 0 : 
                         (selectedColorOption === 'colour1' ? 1 : 
                         (selectedColorOption === 'colour2' ? 2 : 3));

   // Apply button background color
   const selectedButtonColor = buttonColors[selectedIndex];
   const selectedButtonHoverColor = buttonHoverColors[selectedIndex];

   button.style.backgroundColor = selectedButtonColor;

   button.addEventListener('mouseenter', () => {
      button.style.backgroundColor = selectedButtonHoverColor;
   });

   button.addEventListener('mouseleave', () => {
      button.style.backgroundColor = selectedButtonColor;
   });
}

// Add event listener for the color selector
document.getElementById('colorSelector').addEventListener('change', function() {
   const selectedColorOption = this.value;
   localStorage.setItem('selectedColorOption', selectedColorOption); // Save to local storage

   // Update colors for existing buttons
   const buttons = document.querySelectorAll(
      '.theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #settings-btn1, #flush-button, #optToggleButton, #settings-btn2, #acccessibility-btn1, #import-btn, #tile-size, #colorSelector, #popup-button, #reroll-btn, #local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #urlimage-btn, #urlURL-popup-close, #url-popup-close-url1, #popup-close, .collapsible, .edit-popup button, #submit-url-btn, #submit-url-btn1, #share-url-popup button, #nsfw-inclusion-popup button, #image-upload-choice-popup button, #tile-creation-popup button, #settings-popup button,  #tileSize, #undo-delete-popup button, #popup-close-btn, #new-confirm-image-btn, #confirm-image-btn, #new-cancel-image-btn, #cancel-image-btn, #image-confirmation-popup button, #new-image-confirmation-popup button, .link-button, #close-links-popup, #accessibility-popup button, #theme-dropdown-accessibility, #close-multi-links-popup, #font-dropdown, #close-formatting, .remove-custom-field-btn'
   );

   // Update each button's color
   buttons.forEach(button => {
      applyDynamicButtonColors(button);
   });
});
// Save the selected color option in localStorage
// Save the selected color option in localStorage
document.getElementById('colorSelector').addEventListener('change', function() {
    const selectedColorOption = this.value; 
    localStorage.setItem('selectedColorOption', selectedColorOption); // Save to local storage

    const nsfwTiles = document.querySelectorAll('.nsfw-outline, .highlight-nsfw');
    const specialTiles = document.querySelectorAll('.special-outline');
    const starTiles = document.querySelectorAll('.star-outline, .highlight-favourite');

    // Select all specified buttons
    const buttons = document.querySelectorAll(
   '#url-image-btn, theme-toggle button, #tag-filter, #tag-filter-mobile, #export-btn, #settings-btn1, #flush-button, #optToggleButton, #settings-btn2, #acccessibility-btn1, #import-btn, #tile-size, #colorSelector, #popup-button, #reroll-btn, #local-upload-btn, #url-upload-btn, #url-popup-close, #url-popup-close-url, #local-image-btn, #urlimage-btn, #urlURL-popup-close, #url-popup-close-url1, #popup-close, .collapsible, .edit-popup button, #submit-url-btn, #submit-url-btn1, #share-url-popup button, #nsfw-inclusion-popup button, #image-upload-choice-popup button, #tile-creation-popup button, #settings-popup button,  #tileSize, #undo-delete-popup button, #popup-close-btn, #new-confirm-image-btn, #confirm-image-btn, #new-cancel-image-btn, #cancel-image-btn, #image-confirmation-popup button, #new-image-confirmation-popup button, .link-button, #close-links-popup, #accessibility-popup button, #theme-dropdown-accessibility, #close-multi-links-popup, #font-dropdown, #close-formatting, .remove-custom-field-btn' // Added .remove-custom-field-btn
    );

    // Define colors based on the selected option
    const nsfwColors = [
        'var(--nsfw-color-1)', 
        'var(--nsfw-color-2)', 
        'var(--nsfw-color-3)', 
        'var(--nsfw-color-4)'  
    ];

    const specialColors = [
        'var(--special-outline-color-1)', 
        'var(--special-outline-color-2)', 
        'var(--special-outline-color-3)', 
        'var(--special-outline-color-4)'  
    ];

    const starColors = [
        'var(--star-outline-color-1)', 
        'var(--star-outline-color-2)', 
        'var(--star-outline-color-3)', 
        'var(--star-outline-color-4)'  
    ];

    const buttonColors = [
        'var(--button-bg-1)', 
        'var(--button-bg-2)', 
        'var(--button-bg-3)', 
        'var(--button-bg-4)'  
    ];

    const buttonHoverColors = [
        'var(--button-bg-hover-1)', 
        'var(--button-bg-hover-2)', 
        'var(--button-bg-hover-3)', 
        'var(--button-bg-hover-4)'  
    ];

    const selectedIndex = this.value === 'original' ? 0 : 
                          (this.value === 'colour1' ? 1 : 
                          (this.value === 'colour2' ? 2 : 3));

    // Get selected colors
    const selectedNsfwColor = nsfwColors[selectedIndex];
    const selectedSpecialColor = specialColors[selectedIndex];
    const selectedStarColor = starColors[selectedIndex];
    const selectedButtonColor = buttonColors[selectedIndex];
    const selectedButtonHoverColor = buttonHoverColors[selectedIndex];

    // Apply colors
    specialTiles.forEach(tile => tile.style.borderColor = selectedSpecialColor);
    nsfwTiles.forEach(tile => {
        if (!tile.classList.contains('special-outline')) {
            tile.style.borderColor = selectedNsfwColor;
        }
    });
    starTiles.forEach(tile => {
        if (!tile.classList.contains('special-outline')) {
            tile.style.borderColor = selectedStarColor;
        }
    });

    // Apply button background color
    buttons.forEach(button => {
        button.style.backgroundColor = selectedButtonColor;

        // Set up hover effect through CSS for specified selectors
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = selectedButtonHoverColor;
        });
        button.addEventListener('mouseleave', () => {
            button.style.backgroundColor = selectedButtonColor;
        });
    });

    // Remove any existing dynamic style tag for the link-button class
    const existingStyleTag = document.getElementById('link-button-style');
    if (existingStyleTag) {
        existingStyleTag.remove();
    }

    // Create a new style element for the link-button with !important rules
    const styleTag = document.createElement('style');
    styleTag.id = 'link-button-style';
    styleTag.innerHTML = `
        .link-button {
            background-color: ${selectedButtonColor} !important;
        }
        .link-button:hover {
            background-color: ${selectedButtonHoverColor} !important;
        }
    `;
    document.head.appendChild(styleTag);
});


// Load the selected color option on page load
function loadSelectedColorOption() {
    const savedOption = localStorage.getItem('selectedColorOption');
    if (savedOption) {
        const colorSelector = document.getElementById('colorSelector');
        colorSelector.value = savedOption; // Set the dropdown to the saved value
        // Trigger change event to apply the colors
        const event = new Event('change');
        colorSelector.dispatchEvent(event);
    }
}



document.getElementById('toggleButton').addEventListener('click', function() {
    // Get all elements with class 'edit-image-btn', 'edit-url-btn', etc.
    const editButtons = document.querySelectorAll('.edit-image-btn');
    const editURL = document.querySelectorAll('.edit-url-btn');
    const editTags = document.querySelectorAll('.edit-tags-btn');
    const editInfo = document.querySelectorAll('.edit-info-btn');
    const editDelete = document.querySelectorAll('.delete-btn');
    
    // Toggle the display property for each button
    const toggleDisplay = (buttons) => {
        buttons.forEach(button => {
            button.style.display = button.style.display === 'none' ? 'flex' : 'none';
        });
    };

    toggleDisplay(editButtons);
    toggleDisplay(editURL);
    toggleDisplay(editTags);
    toggleDisplay(editInfo);
    toggleDisplay(editDelete);

    // Check the current state of the button and save it to localStorage
    const isHidden = editButtons[0].style.display === 'none';
    localStorage.setItem('buttonsHidden', isHidden);

    // Change the text of the toggle button
    this.textContent = isHidden ? 'Show Tile Buttons' : 'Hide Tile Buttons';
});



tagFilterMobile.addEventListener('change', filterTilesMobile);

function updateTagFilterMobile() {
    const currentFilter = tagFilterMobile.value;
    tagFilterMobile.innerHTML = '<option value="all">All Tags</option>';

    allTags.forEach(tag => {
        // Truncate tag if longer than 12 characters
        const displayTag = tag.length > 12 ? tag.slice(0, 12) + '...' : tag;

        // Add star-related tags as "⭐" if any exist
        if (starTags.includes(tag)) {
            if (!Array.from(tagFilterMobile.options).some(option => option.value === '⭐')) {
                const option = document.createElement('option');
                option.value = '⭐';
                option.textContent = '⭐';
                tagFilterMobile.appendChild(option);
            }
        } 
        // Add NSFW and 18+ tags separately
        else if (nsfwTags.includes(tag)) {
            if (!Array.from(tagFilterMobile.options).some(option => option.value === tag)) {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = displayTag;  // Apply truncation
                tagFilterMobile.appendChild(option);
            }
        } else {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = displayTag;  // Apply truncation
            tagFilterMobile.appendChild(option);
        }
    });

    tagFilterMobile.value = currentFilter;
    filterTilesMobile();
}


function filterTilesMobile() {
    const selectedTag = tagFilterMobile.value;
    tiles.forEach((tile, index) => {
        const tileElement = imageGrid.children[index];

        // Check if the tile matches the selected tag or its equivalent
        const isMatchingTag = selectedTag === 'all' ||
            tile.tags.includes(selectedTag) ||
            tile.platform === selectedTag

        // Treat ⭐ as matching all star-related tags
        const isStarEquivalent = (selectedTag === '⭐' && tile.tags.some(tag => starTags.includes(tag)));

        // Treat 18+ as matching both "NSFW" and "18+"
        const isNSFWEquivalent = (selectedTag === 'NSFW' && tile.tags.some(tag => nsfwTags.includes(tag)));

        if (isMatchingTag || isStarEquivalent || isNSFWEquivalent) {
            tileElement.style.display = '';
        } else {
            tileElement.style.display = 'none';
        }
    });
}

addImageButton.addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'block';
    document.getElementById('popup-overlay').style.display = 'block';
});

// Add event listeners for the new buttons
document.getElementById('local-image-btn').addEventListener('click', () => {
    fileInput.click();
});

document.getElementById('url-image-btn').addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'none';
    document.getElementById('url-input-popup').style.display = 'block';
});

document.getElementById('submit-url-btn').addEventListener('click', () => {
    const imageUrl = document.getElementById('image-url-input').value.trim();
    if (imageUrl) {
        // Set the preview image
        document.getElementById('new-preview-image').src = imageUrl; 

        // Show the confirmation popup
        document.getElementById('new-image-confirmation-popup').style.display = 'block';
        document.getElementById('popup-overlay1').style.display = 'block';
        // Confirm button click event
        document.getElementById('new-confirm-image-btn').onclick = () => {
            // Trigger the tile creation popup with the confirmed image URL
            document.getElementById('url-input-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
            document.getElementById('popup-overlay1').style.display = 'none';
            document.getElementById('new-image-confirmation-popup').style.display = 'none';
            showTileCreationPopup(imageUrl);
            closePopups(); // Close all popups
        };

        // Cancel button click event
        document.getElementById('new-cancel-image-btn').onclick = () => {
            document.getElementById('new-image-confirmation-popup').style.display = 'none';
            document.getElementById('popup-overlay1').style.display = 'none';
            closePopups(); // Just close the popups without taking any action
        };

        // Close the URL input popup
    }
});

document.getElementById('create-tile-btn').addEventListener('click', () => {
    document.getElementById('popup-overlay').style.display = 'none';
});

document.getElementById('url-popup-close-url1').addEventListener('click', () => {
    document.getElementById('url-input-popup').style.display = 'none';
    document.getElementById('popup-overlay').style.display = 'none';
});

document.getElementById('urlURL-popup-close').addEventListener('click', () => {
    document.getElementById('image-source-popup').style.display = 'none';
    document.getElementById('popup-overlay').style.display = 'none';
});
document.getElementById('settings-close').addEventListener('click', () => {
    document.getElementById('popup-overlay').style.display = 'none';
    document.getElementById('settings-popup').style.display = 'none';
});
document.getElementById('accessibility-settings-close').addEventListener('click', () => {
    document.getElementById('accessibility-popup').style.display = 'none';
    document.getElementById('popup-overlay').style.display = 'none';
});

function showEditUrlPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-url-popup');
   const urlInput = document.getElementById('edit-url-input');
   const originalUrl = tileData.link; // Store the original URL
   urlInput.value = originalUrl; // Set the input value to the original URL
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('save-url-btn').onclick = () => {
      tileData.link = urlInput.value; // Update the tile data
      tileElement.querySelector('a').href = tileData.link; // Update the link in the tile element
      saveTiles(); // Save to local storage
      popup.style.display = 'none'; // Close the popup
      document.getElementById('popup-overlay').style.display = 'none';
   };

   // Handle cancel button with unsaved changes prompt
   document.getElementById('cancel-url-btn').onclick = () => {
      const currentUrl = urlInput.value; // Get the current URL input value

      // Check if there are unsaved changes
      if (currentUrl !== originalUrl) {
         const confirmCancel = confirm("You have unsaved changes. Are you sure you want to cancel?");
         if (!confirmCancel) {
            return; // If the user does not confirm, do nothing
         }
      }

      // If no unsaved changes or the user confirmed, close the popup
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}

const forceMobileButtonsBtn = document.getElementById('force-mobile-buttons');

function applyMobileButtonState(isForced) {
    const buttons = [
        '.edit-popup textarea',
        '#nsfw-inclusion-popup button',
        '#local-upload-btn',
        '.edit-popup button',
        '#share-url-popup button',
        '#export-btn',
        '#import-btn',
        '#tile-size',
        '#url-upload-btn',
        '#url-popup-close',
        '#colorSelector',
        '#settings-popup button',
        '#tileSize',
        '#accessibility-popup button',
        '#settings-btn',
        '#settings-btn2',
        '#acccessibility-btn',
        '#random-character-btn',
        '#flush-button',
        'optToggleButton',
        '#openReorderToolButton',
        '#openBackupMergeButton',
        '.theme-toggle' // Keep this here but handle separately
    ];

    // Apply full-width class and set padding for buttons
    buttons.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(element => {
            if (selector !== '.theme-toggle') {
                element.classList.toggle('full-width', isForced);
                element.style.padding = '15px'; // Apply 15px padding
            }
        });
    });

    // Set .theme-toggle to 100% width and no padding
    const themeToggleElements = document.querySelectorAll('.theme-toggle');
    themeToggleElements.forEach(element => {
        element.style.width = '100%'; // Explicitly set width to 100%
        element.style.padding = '0'; // Ensure no padding
    });

    // Set padding for #tag-filter-mobile
    const tagFilterMobile = document.getElementById('tag-filter-mobile');
    if (tagFilterMobile) {
        tagFilterMobile.style.padding = '15px'; // Apply 15px padding
    }

    // Set visibility of tag filter elements
    const tagFilter = document.getElementById('tag-filter');
    
    if (tagFilter) {
        tagFilter.style.display = isForced ? 'none' : 'block';
    }
    
    if (tagFilterMobile) {
        tagFilterMobile.style.display = isForced ? 'block' : 'none';
    }

    // Update button text
    forceMobileButtonsBtn.textContent = isForced ? 'Undo Force Mobile Buttons' : 'Force Mobile Buttons';
}

forceMobileButtonsBtn.addEventListener('click', function() {
    const isForced = localStorage.getItem('forceMobileButtons') !== 'true';
    localStorage.setItem('forceMobileButtons', isForced.toString());
    applyMobileButtonState(isForced);
});

// Apply saved settings on page load
document.addEventListener('DOMContentLoaded', function() {
    const isForced = localStorage.getItem('forceMobileButtons') === 'true';
    applyMobileButtonState(isForced);
});




function filterTilesByPlatform() {
   const selectedPlatform = document.getElementById('platform-filter').value;
   const tiles = document.querySelectorAll('.tile'); // Assuming .tile is the class for each tile

   tiles.forEach(tile => {
      const platform = tile.getAttribute('data-platform'); // Assuming platform info is stored in a data attribute

      if (selectedPlatform === 'all' || platform === selectedPlatform) {
         tile.style.display = 'block'; // Show the tile
      } else {
         tile.style.display = 'none'; // Hide the tile
      }
   });
}


function showEditInfoPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-info-popup');
   const customFieldsContainer = document.getElementById('custom-fields');

   // Set values for default fields
   document.getElementById('edit-name-input').value = tileData.name || '';
   document.getElementById('edit-platform-input').value = tileData.platform || '';
   document.getElementById('edit-age-input').value = tileData.age || '';
   document.getElementById('edit-description-input').value = tileData.description || '';
   document.getElementById('edit-alt-input').value = tileData.alt || '';

   // Clear existing custom fields
   customFieldsContainer.innerHTML = '';

   // Add existing custom fields
   if (tileData.customFields) {
      for (const [key, value] of Object.entries(tileData.customFields)) {
         addCustomField(key, value);
      }
   }

   // Add Custom Field button functionality
   document.getElementById('add-custom-field-btn').onclick = () => {
      addCustomField();
   };

   // Add event listener for shortcuts
   customFieldsContainer.addEventListener('keydown', (event) => {
      const activeElement = document.activeElement;

      // Check if the active element is a textarea for custom field values
      if (activeElement.classList.contains('custom-field-value')) {
    let wrappedText;
    const start = activeElement.selectionStart;
    const end = activeElement.selectionEnd;
    const text = activeElement.value;

    // Determine if the user is on macOS or not
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;

    // Handle formatting shortcuts
    if (event.ctrlKey || (isMac && event.metaKey)) { // Use Command key for macOS
    switch (event.key) {
        case 'b':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(b)${text.substring(start, end)}(/b)`;
            }
            break;
        case 'i':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(i)${text.substring(start, end)}(/i)`;
            }
            break;
        case 'u':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(u)${text.substring(start, end)}(/u)`;
            }
            break;
        case '=':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(sub)${text.substring(start, end)}(/sub)`;
            }
            break;
        case '+':
            if (event.shiftKey) { // Check if Shift is also pressed
                event.preventDefault();
                if (start !== end) {
                    wrappedText = `(sup)${text.substring(start, end)}(/sup)`;
                }
            }
            break;
        case 'l':
            if (event.altKey) { // Check if Alt is also pressed
                event.preventDefault();
                if (start !== end) {
                    wrappedText = `(letterspace="")${text.substring(start, end)}(/letterspace)`;
                }
            }
            break;
        case 'L':
            event.preventDefault(); // Prevent default action for Ctrl + L
            if (start !== end) {
                wrappedText = `(letterspace="")${text.substring(start, end)}(/letterspace)`;
            }
            break; 
        case '#':
            event.preventDefault();
            // Find the start of the current line
            const currentLineStartHash = text.lastIndexOf('\n', start - 1) + 1; 
            const currentLineTextHash = text.substring(currentLineStartHash, text.indexOf('\n', currentLineStartHash));
            
            // Check if the line already starts with '(#)'
            if (!currentLineTextHash.trim().startsWith('(#[)')) {
                // Insert '(#)' at the beginning of the line if it's not already there
                activeElement.value = text.substring(0, currentLineStartHash) + '(#)' + text.substring(currentLineStartHash);
                activeElement.selectionStart = currentLineStartHash + 3; // Move the cursor after '(#)'
                activeElement.selectionEnd = activeElement.selectionStart; // Set the selection end to the same position
            }
            break;

        case '-':
            event.preventDefault();
            // Find the start of the current line
            const currentLineStartDash = text.lastIndexOf('\n', start - 1) + 1; 
            const currentLineTextDash = text.substring(currentLineStartDash, text.indexOf('\n', currentLineStartDash));
            
            // Check if the line already starts with '(-)'
            if (!currentLineTextDash.trim().startsWith('(-)')) {
                // Insert '(-)' at the beginning of the line if it's not already there
                activeElement.value = text.substring(0, currentLineStartDash) + '(-)' + text.substring(currentLineStartDash);
                activeElement.selectionStart = currentLineStartDash + 3; // Move the cursor after '(-)'
                activeElement.selectionEnd = activeElement.selectionStart; // Set the selection end to the same position
            }
            break;

        case '|':
            event.preventDefault();
            // Insert '(ind)' at the current cursor position
            activeElement.value = text.substring(0, start) + '(ind)' + text.substring(end);
            activeElement.selectionStart = start + 5; // Move the cursor after '(ind)'
            activeElement.selectionEnd = activeElement.selectionStart; // Set the selection end to the same position
            break;

        case 's':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(s)${text.substring(start, end)}(/s)`;
            }
            break;
        case 'k':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(c)${text.substring(start, end)}(/c)`;
            }
            break;
        case 'q':
            event.preventDefault();
            if (start !== end) {
                wrappedText = `(q)${text.substring(start, end)}(/q)`;
            }
            break;
        case 'I':
            if (event.altKey) {
                event.preventDefault();
                if (start !== end) {
                    wrappedText = `(ind)${text.substring(start, end)}`;
                }
            }
            break;
        case 'b':
            if (event.shiftKey) {
                event.preventDefault();
                if (start !== end) {
                    wrappedText = `(blur)${text.substring(start, end)}(/blur)`;
                }
            }
            break;
        default:
            return; // Do nothing if another key is pressed with Ctrl or Command
    }
}
      }

   });

   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('save-info-btn').onclick = () => {
      tileData.name = document.getElementById('edit-name-input').value;
      tileData.platform = document.getElementById('edit-platform-input').value;
      tileData.age = document.getElementById('edit-age-input').value;
      tileData.description = document.getElementById('edit-description-input').value;
      tileData.alt = document.getElementById('edit-alt-input').value;

      // Save custom fields
      tileData.customFields = {};
      document.querySelectorAll('.custom-field').forEach(field => {
         const key = field.querySelector('.custom-field-key').value;
         const value = field.querySelector('.custom-field-value').value;
         if (key && value) {
            tileData.customFields[key] = value;
         }
      });

      // Update the alt text of the corresponding <img> element
      const imgElement = tileElement.querySelector('img');
      if (imgElement) {
         imgElement.alt = tileData.alt;
      }

      saveTiles(); // Save to local storage
      updateAllTags();
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };

   document.getElementById('cancel-info-btn').onclick = () => {
   // Get the current values from the inputs
   const currentName = document.getElementById('edit-name-input').value;
   const currentPlatform = document.getElementById('edit-platform-input').value;
   const currentAge = document.getElementById('edit-age-input').value;
   const currentDescription = document.getElementById('edit-description-input').value;
   const currentAlt = document.getElementById('edit-alt-input').value;

   // Get the current custom fields
   const currentCustomFields = {};
   document.querySelectorAll('.custom-field').forEach(field => {
      const key = field.querySelector('.custom-field-key').value;
      const value = field.querySelector('.custom-field-value').value;
      if (key && value) {
         currentCustomFields[key] = value;
      }
   });

   // Check if any changes were made
   const hasUnsavedChanges = (
      currentName !== (tileData.name || '') ||
      currentPlatform !== (tileData.platform || '') ||
      currentAge !== (tileData.age || '') ||
      currentDescription !== (tileData.description || '') ||
      currentAlt !== (tileData.alt || '') ||
      JSON.stringify(currentCustomFields) !== JSON.stringify(tileData.customFields || {})
   );

   // If there are unsaved changes, prompt the user
   if (hasUnsavedChanges) {
      const confirmCancel = confirm("You have unsaved changes. Are you sure you want to cancel?");
      if (!confirmCancel) {
         return; // If the user does not confirm, do nothing
      }
   }

   // If no unsaved changes or the user confirmed, close the popup
   popup.style.display = 'none';
   document.getElementById('popup-overlay').style.display = 'none';
};

}

// Function to add custom fields
function addCustomField(key = '', value = '') {
   const customFieldsContainer = document.getElementById('custom-fields');
   const fieldDiv = document.createElement('div');
   fieldDiv.className = 'custom-field';
   fieldDiv.innerHTML = `
    <input type="text" class="custom-field-key" placeholder="Field Name" value="${key}">
    <textarea class="custom-field-value" placeholder="Field Value">${value}</textarea>
    <button class="remove-custom-field-btn" style="margin-bottom:0px">Remove</button>
    <div style="display: flex; gap: 5px;"> <!-- Flex container for buttons -->
        <button class="move-up-btn" style="margin-bottom:10px">Move Up</button>
        <button class="move-down-btn" style="margin-bottom:10px">Move Down</button>
    </div>
`;

   customFieldsContainer.appendChild(fieldDiv);

   // Set the onclick event for removing the custom field
   const removeBtn = fieldDiv.querySelector('.remove-custom-field-btn');
   removeBtn.classList.add('test');
   removeBtn.onclick = () => {
      customFieldsContainer.removeChild(fieldDiv);
   };

   // Set the onclick event for moving the custom field up
   const moveUpBtn = fieldDiv.querySelector('.move-up-btn');
   moveUpBtn.classList.add('test');
   moveUpBtn.onclick = () => {
      const prevSibling = fieldDiv.previousElementSibling;
      if (prevSibling) {
         customFieldsContainer.insertBefore(fieldDiv, prevSibling);
      }
   };

   // Set the onclick event for moving the custom field down
   const moveDownBtn = fieldDiv.querySelector('.move-down-btn');
   moveDownBtn.classList.add('test');
   moveDownBtn.onclick = () => {
      const nextSibling = fieldDiv.nextElementSibling;
      if (nextSibling) {
         customFieldsContainer.insertBefore(nextSibling, fieldDiv);
      }
   };

   // Apply dynamic colors to the buttons
   applyDynamicButtonColors(removeBtn);
   applyDynamicButtonColors(moveUpBtn);
   applyDynamicButtonColors(moveDownBtn);
}

// Function to show the edit tags popup
function showEditTagsPopup(tileData, tileElement) {
   const popup = document.getElementById('edit-tags-popup');
   const originalTags = tileData.tags.slice(); // Make a copy of the original tags
   document.getElementById('edit-tags-input').value = originalTags.join(', ');
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('save-tags-btn').onclick = () => {
      const newTags = document.getElementById('edit-tags-input').value.split(',')
         .map(tag => tag.trim()) // Trim whitespace from each tag
         .filter(tag => tag) // Remove empty tags
         .filter((tag, index, self) => self.indexOf(tag) === index); // Remove duplicates

      tileData.tags = newTags;
      updateTileTags(tileElement, tileData.tags);
      updateTileOutline(tileElement, tileData.tags);
      saveTiles();
      updateTagFilter();
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };

   document.getElementById('cancel-tags-btn').onclick = () => {
      // Get the current value of the input
      const currentTags = document.getElementById('edit-tags-input').value.split(',')
         .map(tag => tag.trim())
         .filter(tag => tag);

      // Check if any changes were made
      const hasUnsavedChanges = (
         currentTags.length !== originalTags.length || // Check if the number of tags is different
         currentTags.some((tag, index) => tag !== originalTags[index]) // Check for any differing tags
      );

      // If there are unsaved changes, prompt the user
      if (hasUnsavedChanges) {
         const confirmCancel = confirm("You have unsaved changes. Are you sure you want to cancel?");
         if (!confirmCancel) {
            return; // If the user does not confirm, do nothing
         }
      }

      // If no unsaved changes or the user confirmed, close the popup
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}


// Theme management
function setTheme(theme) {
   document.body.className = theme;
   localStorage.setItem('theme', theme);
}
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
   coll[i].addEventListener("click", function () {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.maxHeight) {
         content.style.maxHeight = null;
      } else {
         content.style.maxHeight = content.scrollHeight + "px";
      }
   });
}

const themeToggleBtn = document.getElementById('theme-toggle-btn');

const themes = ['', 'dark-mode', 'amoled-mode'];
let currentThemeIndex = 0;  // Index to track the current theme

function setTheme(theme) {
    const accessTheme = localStorage.getItem('accessTheme');
    // Save the theme value in local storage
    localStorage.setItem('theme', theme);

    // Update the button text based on the theme
    if (theme === '') {
        themeToggleBtn.textContent = 'Light Mode';
    } else if (theme === 'dark-mode') {
        themeToggleBtn.textContent = 'Dark Mode';
    } else if (theme === 'amoled-mode') {
        themeToggleBtn.textContent = 'Amoled Mode';
    }

    // Apply the theme only if accessTheme has no value
    if (!accessTheme) {
        document.body.className = theme;
    }
}

// Function to cycle through the themes
function toggleTheme() {
    // Move to the next theme
    currentThemeIndex = (currentThemeIndex + 1) % themes.length;
    setTheme(themes[currentThemeIndex]);
}
// Apply theme on load
applyStoredTheme();
// Function to apply the stored theme on page load
function applyStoredTheme() {
    const accessTheme = localStorage.getItem('accessTheme');
    const storedTheme = localStorage.getItem('theme') || '';

    // Set the theme based on the stored value
    setTheme(storedTheme); 
        applyTheme(); // Apply the accessTheme
}


// Add event listener to the button
themeToggleBtn.addEventListener('click', toggleTheme);




// Get the select element
const themeDropdown = document.getElementById('theme-dropdown-accessibility');


// Function to apply the theme based on the value in local storage
function applyTheme() {
    const theme = localStorage.getItem('accessTheme');

    // Remove existing theme classes
    document.body.classList.remove('high-contrast-dark-mode', 'high-contrast-light-mode');

    // Add the new theme class if applicable
    if (theme === 'high-contrast-dark-mode') {
        document.body.classList.add('high-contrast-dark-mode');
    } else if (theme === 'high-contrast-light-mode') {
        document.body.classList.add('high-contrast-light-mode');
    }
}

// Load the theme from local storage on page load
themeDropdown.addEventListener('change', function () {
    const selectedValue = this.value;

    // Check if the selected value is not "disabled"
    if (selectedValue !== 'disabled') {
        const accessTheme = selectedValue === 'high-contrast-dark' ? 'high-contrast-dark-mode' : 'high-contrast-light-mode';

        // Store the value in local storage
        
        localStorage.setItem('accessTheme', accessTheme);

        // Apply the theme
        applyTheme();
    } else {
        // Remove the item from storage if "disabled" is selected
        localStorage.removeItem('accessTheme');
        // Remove any applied theme
        applyTheme();
        window.location.reload();
    }
});




// Load saved tiles
function loadSavedTiles() {
   tiles = JSON.parse(localStorage.getItem('imageTiles')) || [];
   tiles.forEach(tile => {
      createImageTile(tile);
      tile.tags.forEach(tag => allTags.add(tag));
   });
   updateAllTags();
}

// Save tiles
function saveTiles() {
   localStorage.setItem('imageTiles', JSON.stringify(tiles));
}

function createImageTile(tileData) {
   const newImageItem = document.createElement('div');
   newImageItem.className = 'image-item';

   const hasNSFW = tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn') || tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞');
   const hasStar = tileData.tags.includes('⭐') || tileData.tags.includes('✨') || tileData.tags.includes('🌠') || tileData.tags.includes('🌟') ||
                   tileData.tags.includes('💫') || tileData.tags.includes('🤩') || tileData.tags.includes('❇️') || tileData.tags.includes('✴️') ||
                   tileData.tags.includes('✳️') || tileData.tags.includes('🔥') || tileData.tags.includes('💎');

   if (hasNSFW) {
      newImageItem.classList.add('nsfw-outline');
   }
   if (hasStar) {
      newImageItem.classList.add('star-outline');
   }
   if (hasNSFW && hasStar) {
      newImageItem.classList.add('special-outline');
   }

   newImageItem.innerHTML = `
                <a href="${tileData.link}" target="_blank" class="image-container">
                    <img src="${tileData.imageData}" alt="${tileData.alt || 'User uploaded image'}"> <!-- Set alt text -->
                </a>
                <div class="tile-buttons">
                    <button class="edit-image-btn" title="Edit Image" alt="Edit Image Button">🖼️</button>
                    <button class="edit-url-btn" title="Edit URL" alt="Edit URL Button">🔗</button>
                    <button class="edit-tags-btn" title="Edit Tags" alt="Edit Tags Button">🏷️</button>
                    <button class="edit-info-btn" title="Edit Info" alt="Edit Character Information Button">ℹ️</button>
                    <button class="share-btn" title="Share" alt="Share URL Button">📤</button>
                    <button class="delete-btn" title="Delete" alt="Delete Tile">×</button>
                </div>
                <div class="tags">
                    ${tileData.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
            `;

   const tiles = Array.from(imageGrid.children);
   const lastTile = tiles.filter(tile => !tile.classList.contains('add-image')).pop();

   if (lastTile) {
      imageGrid.insertBefore(newImageItem, lastTile.nextSibling);
   } else {
      imageGrid.insertBefore(newImageItem, imageGrid.firstChild);
   }

   // Add edit image functionality
   newImageItem.querySelector('.edit-image-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      editImage(tileData, newImageItem);
   });

   newImageItem.querySelector('.edit-tags-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      showEditTagsPopup(tileData, newImageItem);
   });

   newImageItem.querySelector('.share-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      shareTile(tileData);
   });

   newImageItem.querySelector('.delete-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteTile(tileData, newImageItem);
   });

   newImageItem.querySelector('.edit-url-btn').addEventListener('click', (e) => {
      e.stopPropagation();
         showEditUrlPopup(tileData, newImageItem);
   });

   newImageItem.querySelector('.edit-info-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      showEditInfoPopup(tileData, newImageItem);
   });
}

document.getElementById('popup-overlay').addEventListener('click', () => {
   document.getElementById('image-source-popup').style.display = 'none';
   document.getElementById('url-input-popup').style.display = 'none';
   document.getElementById('popup-overlay').style.display = 'none';
   document.getElementById('settings-popup').style.display = 'none';
   document.getElementById('settings-popout').style.display = 'none';
   document.getElementById('accessibility-popup').style.display = 'none';
   document.getElementById('edit-url-popup').style.display = 'none';
   document.getElementById('tile-creation-popup').style.display = 'none';
   document.getElementById('character-popup').style.display = 'none';
   document.getElementById('edit-info-popup').style.display = 'none';
   document.getElementById('edit-tags-popup').style.display = 'none';
   document.getElementById('share-url-popup').style.display = 'none';
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
});

document.getElementById('popup-overlay1').addEventListener('click', () => {
    document.getElementById('popup-overlay1').style.display = 'none';
    document.getElementById('new-image-confirmation-popup').style.display = 'none';
    document.getElementById('image-confirmation-popup').style.display= 'none';
    document.getElementById('formatting-guide').style.display = 'none';
});

document.getElementById('close-formatting').addEventListener('click', () => {
    document.getElementById('popup-overlay1').style.display = 'none';
    document.getElementById('formatting-guide').style.display = 'none';
});
function updateTileOutline(tileElement, tags) {
   tileElement.classList.remove('nsfw-outline', 'star-outline', 'special-outline');
   
   const hasNSFW = tags.includes('18+') || tags.includes('NSFW') || tags.includes('Porn') || tags.includes('Hentai') || tags.includes('Yaoi') || tags.includes('🔞');
   const hasStar = tags.includes('⭐') || tags.includes('✨') || tags.includes('🌠') || tags.includes('🌟') ||
                   tags.includes('💫') || tags.includes('🤩') || tags.includes('❇️') || tags.includes('✴️') ||
                   tags.includes('✳️') || tags.includes('🔥') || tags.includes('💎');

   if (hasNSFW && hasStar) {
      tileElement.classList.add('special-outline');
   } else if (hasNSFW) {
      tileElement.classList.add('nsfw-outline');
   } else if (hasStar) {
      tileElement.classList.add('star-outline');
   }
}


function stripUrlParams(url) {
   try {
      const urlObj = new URL(url); // Create a URL object
      return `${urlObj.origin}${urlObj.pathname}`; // Return the base URL without query parameters
   } catch (error) {
      console.error('Invalid URL:', error);
      return url; // Return the original URL if invalid
   }
}

// Edit image
function editImage(tileData, tileElement) {
    console.log('TEST');
    const popup = document.getElementById('image-popup');
    const localUploadBtn = document.getElementById('local-upload-btn');
    const popupClose = document.getElementById('popup-close');
    const urlPopup = document.getElementById('url-popup');
    const urlInput = document.getElementById('image-url-input');
    const urlInput1 = document.getElementById('image-url-input1');
    const submitUrlBtn = document.getElementById('submit-url-btn');
    const urlPopupClose = document.getElementById('url-popup-close');
    const imageUploadClose = document.getElementById('urlURL-popup-close');
    const urlURLPopupClose = document.getElementById('url-popup-close-url');

    // Show the main popup
    popup.classList.remove('hidden');
    document.getElementById('image-popup').style.display = 'block';
    document.getElementById('popup-overlay').style.display = 'block';

    // Close main popup functionality
    popupClose.onclick = () => {
        popup.classList.add('hidden');
        document.getElementById('popup-overlay').style.display = 'none';
    };

    localUploadBtn.onclick = () => {
        console.log('TEST2');
        const imageUploadInput = document.createElement('input');
        imageUploadInput.type = 'file';
        imageUploadInput.accept = 'image/*,.avif,.jxl,.cur,.jps,.jfif';

        imageUploadInput.addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();

                reader.onload = function (e) {
                    const newImageData = e.target.result;
                    // Create a new image element for cropping
                    const img = new Image();
                    img.onload = function() {
                        // Create cropping interface
                        createCroppingInterface(img, (croppedImageData) => {
                            tileData.imageData = croppedImageData;
                            tileElement.querySelector('img').src = croppedImageData;
                            saveTiles();
                        });
                    };
                    img.src = newImageData;
                };

                reader.readAsDataURL(file);
            }
            popup.classList.add('hidden');
            document.getElementById('popup-overlay').style.display = 'none';
            document.getElementById('image-popup').style.display = 'none';
        });

        imageUploadInput.click();
    };

        urlUploadBtn.onclick = () => {

            console.log('TEST3');
            // Hide the main popup and show the URL input popup
            document.getElementById('image-popup').style.display = 'none';
            document.getElementById('url-popup').style.display = 'block';
            popup.classList.add('hidden');
            urlPopup.classList.remove('hidden');
        };

        // Submit URL functionality
        document.getElementById('submit-url-btn1').onclick = () => {
    let imageUrl = urlInput1.value.trim();
    if (imageUrl) {
        document.getElementById('popup-overlay1').style.display = 'block';
        imageUrl = stripUrlParams(imageUrl); // Strip query parameters from URL
        document.getElementById('preview-image').src = imageUrl; // Set preview image

        // Show confirmation popup
        document.getElementById('image-confirmation-popup').style.display = 'block';

        // Confirm button click event
        document.getElementById('confirm-image-btn').onclick = () => {
            document.getElementById('image-confirmation-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
            document.getElementById('popup-overlay1').style.display = 'none';
            document.getElementById('url-popup').style.display = 'none';
            tileData.imageData = imageUrl; // Commit the changes
            tileElement.querySelector('img').src = imageUrl; // Update the tile image
            saveTiles(); // Save the changes
            closePopups(); // Close all popups
        };

        // Cancel button click event
        document.getElementById('cancel-image-btn').onclick = () => {
            document.getElementById('image-confirmation-popup').style.display = 'none';
            document.getElementById('popup-overlay1').style.display = 'none';
        };
    }
};

        // Close URL popup functionality
        urlPopupClose.onclick = () => {
            urlPopup.classList.add('hidden');
            document.getElementById('image-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        };

        urlURLPopupClose.onclick = () => {
            document.getElementById('url-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        };

        
    }

    function createCroppingInterface(image, callback) {
    const croppingPopup = document.createElement('div');
    croppingPopup.classList.add('popupQwErTy');

    const imageContainer = document.createElement('div');
    imageContainer.classList.add('imageContainerAsDfGh');

    const windowWidth = window.innerWidth * 0.8;
    const windowHeight = window.innerHeight * 0.8;
    const aspectRatio = image.naturalWidth / image.naturalHeight;
    let scaledWidth = windowWidth;
    let scaledHeight = windowWidth / aspectRatio;

    if (scaledHeight > windowHeight) {
        scaledHeight = windowHeight;
        scaledWidth = windowHeight * aspectRatio;
    }

    image.style.width = scaledWidth + 'px';
    image.style.height = scaledHeight + 'px';

    const cropBox = document.createElement('div');
    cropBox.classList.add('cropBoxZxCvBn');
    cropBox.classList.add('test');

    const resizeHandle = document.createElement('div');
    resizeHandle.classList.add('resizeHandleUiOpLm');
    resizeHandle.classList.add('test');

    cropBox.appendChild(resizeHandle);
    imageContainer.appendChild(image);
    imageContainer.appendChild(cropBox);
    croppingPopup.appendChild(imageContainer);

    // New container for buttons and dropdowns
    const actionContainer = document.createElement('div');
    actionContainer.style.display = 'flex';
    actionContainer.style.gap = '10px';

    // Confirm button
    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Confirm Crop';
    confirmButton.classList.add('buttonHgFdSa');
    confirmButton.classList.add('test');
    actionContainer.appendChild(confirmButton);

    // Compression dropdown
    const compressionButton = document.createElement('select');
    compressionButton.classList.add('compressionButtonQwErAs');
    compressionButton.classList.add('test');
    const compressionLevels = [
        'None', 
        'Low', 
        'Medium', 
        'High', 
        'Extreme', 
        'Extra Extreme', 
        'Yummers', 
        'Stupidly Low', 
        'What Are Pixels?', 
    ];

    compressionLevels.forEach(level => {
        const option = document.createElement('option');
        option.value = level.toLowerCase();
        option.textContent = level;
        compressionButton.appendChild(option);
    });

    // Load saved compression setting from local storage
    const savedCompression = localStorage.getItem('compressionLevel');
    if (savedCompression) {
        compressionButton.value = savedCompression;
    }

    actionContainer.appendChild(compressionButton);

    // Resize dropdown
    const resizeButton = document.createElement('select');
    resizeButton.classList.add('resizeButtonRtYuIo');
    resizeButton.classList.add('test');
    const resizeOptions = [
        'Image Size: 100%',
        'Image Size: 75%',
        'Image Size: 50%',
        'Image Size: 25%',
        'Image Size: 10%',
    ];

    resizeOptions.forEach(size => {
        const option = document.createElement('option');
        option.value = size.split(': ')[1].replace('%', ''); // Extracting percentage
        option.textContent = size;
        resizeButton.appendChild(option);
    });

    // Load saved resize setting from local storage
    const savedResize = localStorage.getItem('resizePercentage');
    if (savedResize) {
        resizeButton.value = savedResize;
    }

    actionContainer.appendChild(resizeButton);

    croppingPopup.appendChild(actionContainer);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.classList.add('cancelButtonXyZwv');
    cancelButton.classList.add('test');
    croppingPopup.appendChild(cancelButton);

    applyDynamicButtonColors(confirmButton);
    applyDynamicButtonColors(compressionButton);
    applyDynamicButtonColors(resizeButton);
    applyDynamicButtonColors(cancelButton);
    document.body.appendChild(croppingPopup);

    const size = Math.min(scaledWidth, scaledHeight) / 2;
    cropBox.style.width = size + 'px';
    cropBox.style.height = size + 'px';
    cropBox.style.left = (scaledWidth - size) / 2 + 'px';
    cropBox.style.top = (scaledHeight - size) / 2 + 'px';

    let isDragging = false;
    let isResizing = false;
    let startX, startY, startWidth, startHeight;

    cropBox.addEventListener('mousedown', startDragging);
    resizeHandle.addEventListener('mousedown', startResizing);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDragging);

    function startDragging(e) {
        if (e.target === resizeHandle) return;
        isDragging = true;
        startX = e.clientX - cropBox.offsetLeft;
        startY = e.clientY - cropBox.offsetTop;
    }

    function startResizing(e) {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(getComputedStyle(cropBox).width, 10);
        startHeight = parseInt(getComputedStyle(cropBox).height, 10);
        e.stopPropagation();
    }

    function drag(e) {
        if (isDragging) {
            const newLeft = e.clientX - startX;
            const newTop = e.clientY - startY;
            cropBox.style.left = Math.max(0, Math.min(newLeft, scaledWidth - cropBox.offsetWidth)) + 'px';
            cropBox.style.top = Math.max(0, Math.min(newTop, scaledHeight - cropBox.offsetHeight)) + 'px';
        } else if (isResizing) {
            const newSize = Math.min(startWidth + e.clientX - startX, startHeight + e.clientY - startY);
            const maxSize = Math.min(scaledWidth - parseInt(cropBox.style.left, 10), scaledHeight - parseInt(cropBox.style.top, 10));
            cropBox.style.width = Math.min(newSize, maxSize) + 'px';
            cropBox.style.height = cropBox.style.width;
        }
    }

    function stopDragging() {
        isDragging = false;
        isResizing = false;
    }

    confirmButton.onclick = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const cropBoxRect = cropBox.getBoundingClientRect();
        const imageRect = image.getBoundingClientRect();
        const scaleX = image.naturalWidth / imageRect.width;
        const scaleY = image.naturalHeight / imageRect.height;
        canvas.width = cropBoxRect.width * scaleX;
        canvas.height = cropBoxRect.height * scaleY;

        ctx.drawImage(
            image,
            (cropBoxRect.left - imageRect.left) * scaleX,
            (cropBoxRect.top - imageRect.top) * scaleY,
            cropBoxRect.width * scaleX,
            cropBoxRect.height * scaleY,
            0,
            0,
            canvas.width,
            canvas.height
        );

        // Compression logic
        let quality = 1.0;
        switch (compressionButton.value) {
            case 'low': quality = 0.8; break;
            case 'medium': quality = 0.6; break;
            case 'high': quality = 0.4; break;
            case 'extreme': quality = 0.2; break;
            case 'extra extreme': quality = 0.1; break;
            case 'yummers': quality = 0.01; break;
            case 'stupidly low': quality = 0.001; break;
            case 'what are pixels?': break;
            default: quality = 1.0;
        }

        let dataUrl = canvas.toDataURL('image/webp', quality);

        // Resize logic based on the selected option
        const resizePercentage = parseFloat(resizeButton.value) / 100;
        if (resizePercentage !== 1) {
            const resizedCanvas = document.createElement('canvas');
            resizedCanvas.width = canvas.width * resizePercentage;
            resizedCanvas.height = canvas.height * resizePercentage;
            const resizedCtx = resizedCanvas.getContext('2d');
            resizedCtx.drawImage(canvas, 0, 0, resizedCanvas.width, resizedCanvas.height);
            dataUrl = resizedCanvas.toDataURL('image/webp', quality);
        }

        // Save selected options to local storage
        localStorage.setItem('compressionLevel', compressionButton.value);
        localStorage.setItem('resizePercentage', resizeButton.value);

        // Return the resized and compressed image
        callback(dataUrl);
        document.body.removeChild(croppingPopup);
    };

    cancelButton.onclick = () => {
        document.body.removeChild(croppingPopup);
        document.getElementById('popup-overlay').style.display = 'block';
    };
}





document.getElementById('popup-overlay').onclick = () => {
   document.getElementById('url-popup').style.display = 'none';
   document.getElementById('image-popup').style.display = 'none';
};

function createTileData(imageData, link, tags, name, platform, age, description) {
   return {
      imageData,
      link,
      tags,
      name,
      platform,
      age,
      description
   };
}

// Share tile
function shareTile(tileData) {
   const popup = document.getElementById('share-url-popup');
   const urlInput = document.getElementById('share-url-input');
   urlInput.value = tileData.link;
   popup.style.display = 'flex';
   document.getElementById('popup-overlay').style.display = 'block';

   document.getElementById('copy-url-btn').onclick = () => {
      urlInput.select();
      document.execCommand('copy');
      console.log('URL copied to clipboard!');
   };

   document.getElementById('close-share-url-btn').onclick = () => {
      popup.style.display = 'none';
      document.getElementById('popup-overlay').style.display = 'none';
   };
}

// Delete tile
function deleteTile(tileData, tileElement) {
  // Find the index of the tile in the tiles array
  const tileIndex = tiles.indexOf(tileData);

  // Check if the add-image tile is at the beginning
  const addImagePosition = localStorage.getItem('addImagePosition');
  const adjustedIndex = (addImagePosition === 'beginning' && tileIndex >= 1) ? tileIndex + 1 : tileIndex;

  // Clear previous timer and store the new deleted tile data, element, and its adjusted index
  if (undoTimer) {
    clearInterval(undoTimer);
  }
  deletedTile = { data: tileData, element: tileElement, index: adjustedIndex };

  // Remove the tile from the grid and update the tiles array
  tiles.splice(tileIndex, 1);
  imageGrid.removeChild(tileElement);
  saveTiles();
  updateTagFilter();

  // Show the undo popup
  showUndoPopup();
}

function undoDelete() {
  if (deletedTile) {
    // Adjust the index when adding the tile back
    const addImagePosition = localStorage.getItem('addImagePosition');
    const adjustedIndex = (addImagePosition === 'beginning') ? deletedTile.index + 1 : deletedTile.index;

    // Add the tile back to the tiles array at its original index
    tiles.splice(adjustedIndex, 0, deletedTile.data);

    // Find the correct position to insert the tile in the grid
    const nextSibling = imageGrid.children[adjustedIndex] || null;
    imageGrid.insertBefore(deletedTile.element, nextSibling);

    saveTiles();
    updateTagFilter();

    // Hide the undo popup
    hideUndoPopup();
  }
}

undoButton.addEventListener('click', undoDelete);
dismissButton.addEventListener('click', hideUndoPopup);


// Update tile tags
function updateTileTags(tileElement, tags) {
   const tagsContainer = tileElement.querySelector('.tags');
   tagsContainer.innerHTML = tags.map(tag => `<span class="tag">${tag}</span>`).join('');
   updateAllTags();
}

// Update all tags
function updateAllTags() {
   allTags.clear();
   tiles.forEach(tile => {
      // Add regular tags
      tile.tags.forEach(tag => allTags.add(tag));

      // Check if tile.platform exists
      if (tile.platform) {
         // Split the platform by commas, trim whitespace, and add each as a new tag
         const platforms = tile.platform.split(',').map(p => p.trim()).filter(p => p !== '');
         platforms.forEach(platform => allTags.add(platform));
      }
   });
   updateTagFilter();
}


function updateTagFilter() {
    const currentFilter = tagFilter.value;
    tagFilter.innerHTML = '<option value="all">All Tags</option>';
    
    allTags.forEach(tag => {
        // Truncate tag if longer than 12 characters
        const displayTag = tag.length > 12 ? tag.slice(0, 12) + '...' : tag;

        // Add only the ⭐ option if any star-related tags exist
        if (starTags.includes(tag)) {
            if (!Array.from(tagFilter.options).some(option => option.value === '⭐')) {
                const option = document.createElement('option');
                option.value = '⭐';
                option.textContent = '⭐';
                tagFilter.appendChild(option);
            }
        } 
        // Add NSFW and 18+ tags separately
        else if (nsfwTags.includes(tag)) {
            if (!Array.from(tagFilter.options).some(option => option.value === tag)) {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = displayTag;  // Apply truncation
                tagFilter.appendChild(option);
            }
        } else {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = displayTag;  // Apply truncation
            tagFilter.appendChild(option);
        }
    });
    
    tagFilter.value = currentFilter;
    filterTiles();

    // Update mobile tag filter as well
    updateTagFilterMobile();
}



// Filter tiles based on selected tag for desktop
function filterTiles() {
    const selectedTag = tagFilter.value;
    tiles.forEach((tile, index) => {
        const tileElement = imageGrid.children[index];
        
        // Check if the tile matches the selected tag or its equivalent
        const isMatchingTag = selectedTag === 'all' ||
            tile.tags.includes(selectedTag) ||
            tile.platform === selectedTag

        // Treat ⭐ as matching all star-related tags
        const isStarEquivalent = (selectedTag === '⭐' && tile.tags.some(tag => starTags.includes(tag)));

        // Treat 18+ as matching both "NSFW" and "18+"
        const isNSFWEquivalent = (selectedTag === 'NSFW' && tile.tags.some(tag => nsfwTags.includes(tag)));

        if (isMatchingTag || isStarEquivalent || isNSFWEquivalent) {
            tileElement.style.display = '';
        } else {
            tileElement.style.display = 'none';
        }
    });
}

// Handle file selection
fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();

        reader.onload = (e) => {
            const imageData = e.target.result;
            const img = new Image();

            // Set a one-time `onload` handler
            img.onload = () => {
                // Create a canvas to convert the image to WebP
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // Convert canvas to WebP format and pass WebP to cropping interface
                canvas.toBlob((blob) => {
                    const webpUrl = URL.createObjectURL(blob);

                    // Create a temporary image element for WebP image
                    const webpImage = new Image();
                    webpImage.src = webpUrl;

                    webpImage.onload = () => {
                        // Once the WebP image is ready, pass it to the cropping interface
                        createCroppingInterface(webpImage, (croppedImageData) => {
                            showTileCreationPopup(croppedImageData);
                        });
                    };

                    // Clean up: release the blob URL after use
                    webpImage.onloadend = () => {
                        URL.revokeObjectURL(webpUrl);
                    };
                }, 'image/webp', 0.8); // Set WebP format with 80% quality
            };

            // Set the image source to trigger the `onload`
            img.src = imageData;
        };

        reader.readAsDataURL(file);
    }
    document.getElementById('popup-overlay').style.display = 'none';
});




function clearTileCreationPopupInputs() {
    document.getElementById('tile-link').value = '';
    document.getElementById('tile-tags').value = '';
    document.getElementById('tile-name').value = '';
    document.getElementById('tile-platform').value = '';
    document.getElementById('tile-age').value = '';
    document.getElementById('tile-description').value = '';
}


function showTileCreationPopup(imageSource) {
    document.getElementById('image-source-popup').style.display = 'none';
    const popup = document.getElementById('tile-creation-popup');
    popup.style.display = 'flex';
    document.getElementById('popup-overlay').style.display = 'block';

    const createBtn = document.getElementById('create-tile-btn');
    const cancelBtn = document.getElementById('cancel-tile-btn');

    createBtn.onclick = () => {
        const link = document.getElementById('tile-link').value;
        const tags = document.getElementById('tile-tags').value.split(',')
            .map(tag => tag.trim()) // Trim whitespace from each tag
            .filter(tag => tag) // Remove empty tags
            .filter((tag, index, self) => self.indexOf(tag) === index); // Remove duplicates
        const name = document.getElementById('tile-name').value;
        const platform = document.getElementById('tile-platform').value;
        const age = document.getElementById('tile-age').value;
        const description = document.getElementById('tile-description').value;

        // Check for duplicate links
        const hasDuplicateLink = tiles.some(tile => tile.link === link);
        if (hasDuplicateLink) {
            const userResponse = confirm('A tile with this link already exists. Do you want to create a new tile with this duplicate link?');
            if (!userResponse) {
                document.getElementById('popup-overlay').style.display = 'block';
                return; // Don't create the tile if the user cancels
            }
        }

        const newTile = createTileData(imageSource, link, tags, name, platform, age, description);
        tiles.push(newTile);
        createImageTile(newTile);
        saveTiles();
        updateTagFilter();

        popup.style.display = 'none';
        document.getElementById('popup-overlay').style.display = 'none';
        clearTileCreationPopupInputs();
    };

    cancelBtn.onclick = () => {
        popup.style.display = 'none';
        document.getElementById('popup-overlay').style.display = 'none';
        clearTileCreationPopupInputs(); // Optional: Clear the inputs
    };
}



// Filter tiles when tag is selected
tagFilter.addEventListener('change', filterTiles);

// Export functionality
window.addEventListener('load', () => {
    // Check the current opt-out status from local storage
    let hasOptedOut = localStorage.getItem('optOutReminders') === 'true';

    // Function to toggle between opt-in and opt-out
    function toggleOptInOut() {
        if (hasOptedOut) {
            // User is opting back in
            localStorage.setItem('optOutReminders', 'false');
            alert('You have opted in to receive reminders.');

            // Save the current date and time when opting back in
            const currentDateTime = new Date().toISOString();
            localStorage.setItem('pageAccessTimestamp', currentDateTime);
            localStorage.setItem('exportTimestamp', ''); // Clear exportTimestamp if needed
            console.log('Opted back in at: ', currentDateTime);

            optToggleButton.textContent = 'Opt-Out of Reminders';
            hasOptedOut = false;
        } else {
            // User is opting out
            localStorage.setItem('optOutReminders', 'true');
            alert('You have opted out of reminders.');

            // Clear timestamps when opting out
            localStorage.removeItem('pageAccessTimestamp');
            localStorage.removeItem('exportTimestamp');
            console.log('Cleared timestamps on opt-out.');

            optToggleButton.textContent = 'Opt-In to Reminders';
            hasOptedOut = true;
        }
    }

    // Check if the opt-out button exists and add the event listener
    const optToggleButton = document.getElementById('optToggleButton');
    if (optToggleButton) {
        // Set the initial button text based on the opt-out status
        optToggleButton.textContent = hasOptedOut ? 'Opt-In to Reminders' : 'Opt-Out of Reminders';

        // Add event listener to toggle opt-in/opt-out state
        optToggleButton.addEventListener('click', toggleOptInOut);
    }

    // If the user has opted out, skip showing reminders
    if (hasOptedOut) {
        console.log('User has opted out of reminders.');
        return; // Exit early if opted out
    }

    // Check if the page access timestamp already exists
    const pageAccessTimestamp = localStorage.getItem('pageAccessTimestamp');
    const exportTimestamp = localStorage.getItem('exportTimestamp');

    if (!pageAccessTimestamp) {
        // If the page access timestamp doesn't exist, store the current date and time
        const firstAccessTime = new Date().toISOString();
        localStorage.setItem('pageAccessTimestamp', firstAccessTime);
        console.log('First time accessing the page: ', firstAccessTime);
    } else {
        // If the export timestamp doesn't exist, check if 10 days have passed since first access
        if (!exportTimestamp) {
            const firstAccessTime = new Date(pageAccessTimestamp);
            const currentTime = new Date();

            // Calculate the time difference in milliseconds
            const timeDifference = currentTime - firstAccessTime;

            // Convert the time difference to days
            const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));

            if (days >= 10) {
                console.log('It has been 10 or more days since first accessing the page.');
                alert("Hey! It would appear that you haven't exported before. Remember all data associated with the website is stored LOCALLY which means that if for whatever reason the localStorage is wiped, there will be no retrieval of your tiles. This reminder will popup every 10 days and only if you haven't exported before.");
                
                // Update the pageAccessTimestamp to the current time when the alert is shown
                const currentPageAccessTime = new Date().toISOString();
                localStorage.setItem('pageAccessTimestamp', currentPageAccessTime);
                console.log('Page access timestamp updated to: ', currentPageAccessTime);
            } else {
                console.log(`It has only been ${days} days since first accessing the page.`);
            }
        }
    }

    // Handle the export timestamp logic
    if (exportTimestamp) {
        const previousTime = new Date(exportTimestamp);
        const currentTime = new Date();

        // Calculate the time difference in milliseconds
        const timeDifference = currentTime - previousTime;

        // Convert the time difference to days
        const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));

        // Print the time difference in the console
        console.log(`Time since export: ${days} days.`);

        // Check if the time exceeds 30 days
        if (days > 30) {
            alert('Reminder: All the data associated with the website is stored LOCALLY which means that if for whatever reason the localStorage is wiped, there will be no retrieval of your tiles. This reminder will popup every 30 days.');

            // Update the exportTimestamp to the current time when the alert is shown
            const currentExportTime = new Date().toISOString();
            localStorage.setItem('exportTimestamp', currentExportTime);
            console.log('Export timestamp updated to: ', currentExportTime);
        }
    } else {
        console.log('No export timestamp found.');
    }
});



// Event listener for the export button
exportBtn.addEventListener('click', () => {
    // Get the current date and time
    const currentTime = new Date().toISOString();

    // Store the current time in local storage as the export timestamp
    localStorage.setItem('exportTimestamp', currentTime);

    const dataStr = JSON.stringify(tiles);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    const exportFileDefaultName = 'image_grid_data.json';

    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
});

// Import functionality
importBtn.addEventListener('click', () => {
   importFileInput.click();
});

importFileInput.addEventListener('change', (event) => {
   const file = event.target.files[0];
   if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
         const previousTiles = [...tiles]; // Save current tiles state before import
         try {
            const importedTiles = JSON.parse(e.target.result);
            tiles = importedTiles;
            imageGrid.innerHTML = '';  // Clear the grid
            imageGrid.appendChild(addImageButton);  // Re-append the 'add image' button
            tiles.forEach(tile => {
               createImageTile(tile);
               tile.tags.forEach(tag => allTags.add(tag));
            });
            saveTiles();  // Save the new imported tiles
            updateTagFilter();  // Update tag filters
         } catch (error) {
            console.error('Error parsing imported data:', error);
            alert('Error importing data. Please make sure the file is in the correct format.');

            // Restore the previous tiles if there's an error
            tiles = previousTiles;
            imageGrid.innerHTML = '';  // Clear the grid again
            imageGrid.appendChild(addImageButton);  // Re-append the 'add image' button
            tiles.forEach(tile => {
               createImageTile(tile);
               tile.tags.forEach(tag => allTags.add(tag));
            });
         }
      };
      reader.readAsText(file);
   }
});

// Function to toggle blur on NSFW content
function toggleBlurNSFW() {
   const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; // Tags considered NSFW
   const imageItems = document.querySelectorAll('.image-item');

   imageItems.forEach(item => {
      const tags = Array.from(item.querySelectorAll('.tag')).map(tag => tag.textContent);

      if (nsfwTags.some(tag => tags.includes(tag))) {
         const img = item.querySelector('img');
         if (isBlurred) {
            img.style.filter = 'none'; // Unblur
         } else {
            img.style.filter = 'blur(10px)'; // Apply blur
         }
      }
   });

   // Toggle button text and blur state
   isBlurred = !isBlurred;
   localStorage.setItem('isBlurred', JSON.stringify(isBlurred)); // Save blur state in localStorage
   blurNSFWBtn.textContent = isBlurred ? 'Unblur NSFW' : 'Blur NSFW';
}
// Add event listener to the button
blurNSFWBtn.addEventListener('click', toggleBlurNSFW);
// Load saved tiles on page load
loadSavedTiles();
const randomCharacterBtn = document.getElementById('random-character-btn');
const settingsBtn = document.getElementById('settings-btn');
const settingsBtn1 = document.getElementById('settings-btn1');
const settingsBtn2 = document.getElementById('settings-btn2');
const accessibilityBtn = document.getElementById('acccessibility-btn');
const accessibilityBtn1 = document.getElementById('acccessibility-btn1');
const characterPopup = document.getElementById('character-popup');
const formattingGuide = document.getElementById('show-formatting guide');
const popupClose = document.getElementById('popup-close');
const popupCloseBtn = document.getElementById('popup-close-btn');
const popupImage = document.getElementById('popup-image');
const popupTags = document.getElementById('popup-tags');

accessibilityBtn.addEventListener('click', () => {
    document.getElementById('accessibility-popup').style.display = 'flex';
    document.getElementById('popup-overlay').style.display = 'block';
});

accessibilityBtn1.addEventListener('click', () => {
    document.getElementById('accessibility-popup').style.display = 'flex';
    document.getElementById('popup-overlay').style.display = 'block';
    document.getElementById('settings-popout').style.display = 'none';
});

settingsBtn.addEventListener('click', () => {
      document.getElementById('settings-popup').style.display = 'flex';
      document.getElementById('popup-overlay').style.display = 'block';
});
settingsBtn1.addEventListener('click', () => {
      document.getElementById('settings-popup').style.display = 'flex';
      document.getElementById('popup-overlay').style.display = 'block';
      document.getElementById('settings-popout').style.display = 'none';
});
settingsBtn2.addEventListener('click', () => {
      document.getElementById('popup-overlay').style.display = 'block';
      document.getElementById('settings-popout').style.display = 'block';
});
formattingGuide.addEventListener('click', () => {
    document.getElementById('formatting-guide').style.display = 'flex';
    document.getElementById('popup-overlay1').style.display= 'block';
});

// Event listeners for closing popup
popupClose.addEventListener('click', closePopup);
popupCloseBtn.addEventListener('click', closePopup);

// Function to pick a random character
function selectRandomCharacter() {
   const characters = Array.from(document.querySelectorAll('.image-item:not(.add-image)'));
   if (characters.length === 0) {
      alert('No characters available.');
      return;
   }
   let availableCharacters = includeNSFW ? characters : characters.filter(char => {
      const tags = Array.from(char.querySelectorAll('.tag')).map(tag => tag.textContent);
      return !tags.some(tag => ['18+', 'NSFW', 'Porn', 'Hentai', 'Yaoi', '🔞'].includes(tag));
   });
   if (availableCharacters.length === 0) {
      document.getElementById('popup-overlay').style.display = 'none';
      alert('No characters available with current NSFW settings. If you checked the box for it to remember which option you chose, click the "Reset Remembered State" to get the prompt back up.');
      return;
   }
   const randomIndex = Math.floor(Math.random() * availableCharacters.length);
   const selectedCharacter = availableCharacters[randomIndex];
   const tileData = tiles[characters.indexOf(selectedCharacter)];
   
   // Populate the character popup with character data
   document.getElementById('popup-image').src = tileData.imageData;
   document.getElementById('popup-name').innerHTML = `<strong style="font-size: 1.2em;">${tileData.name || 'Unknown'}</strong>`;
   document.getElementById('popup-platform').innerHTML = `<strong style="font-size: 1.2em;">Platform:</strong><br>${tileData.platform || 'N/A'}`;
   document.getElementById('popup-age').innerHTML = `<strong style="font-size: 1.2em;">Age:</strong><br>${tileData.age || 'N/A'}`;
   document.getElementById('popup-description').innerHTML = `<strong style="font-size: 1.2em;">Description:</strong><br>${tileData.description || 'No description available.'}`;
   
   // Populate custom fields
   const customFieldsContainer = document.getElementById('popup-custom-fields');
   customFieldsContainer.innerHTML = ''; // Clear existing custom fields

   function formatText(text) {
   return text
      .replace(/\(b\)(.*?)\(\/b\)/g, '<strong>$1</strong>')
      .replace(/\(i\)(.*?)\(\/i\)/g, '<em>$1</em>')
      .replace(/\(u\)(.*?)\(\/u\)/g, '<u>$1</u>')
      .replace(/\(s\)(.*?)\(\/s\)/g, '<s>$1</s>')
      .replace(/\(link="(.*?)"\)(.*?)\(\/link\)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$2</a>')
      .replace(/\(color="(.*?)"\)(.*?)\(\/color\)/g, '<span style="color: $1;">$2</span>')
      .replace(/\(bgcolor="(.*?)"\)(.*?)\(\/bgcolor\)/g, '<span style="background-color: $1; padding: 5px; border-radius: 4px">$2</span>')
      .replace(/\(c\)(.*?)\(\/c\)/g, '<code>$1</code>') // Inline code formatting
      .replace(/\(q\)(.*?)\(\/q\)/g, '<blockquote>$1</blockquote>') // Block quote formatting
      .replace(/\(sup\)(.*?)\(\/sup\)/g, '<sup>$1</sup>') // Superscript formatting
      .replace(/\(sub\)(.*?)\(\/sub\)/g, '<sub>$1</sub>')  // Subscript formatting
      .replace(/\(letterspace="(.*?)"\)(.*?)\(\/letterspace\)/g, '<span style="letter-spacing: $1;">$2</span>') // Letter spacing formatting
      .replace(/\(ind\)/g, '&nbsp;&nbsp;&nbsp;&nbsp;') // Indentation formatting
      .replace(/\(blur\)(.*?)\(\/blur\)/g, '<span class="blur-text">$1</span>'); // Blur formatting
}

// CSS for blur functionality
const style = document.createElement('style');
style.textContent = `
  .blur-text {
    filter: blur(5px);
    transition: filter 0.3s ease;
  }
  .blur-text:hover {
    filter: none;
  }
`;
document.head.appendChild(style);




if (tileData.customFields) {
  for (const [key, value] of Object.entries(tileData.customFields)) {
    // Create a paragraph for the key
    const fieldElement = document.createElement('p');
    fieldElement.innerHTML = `<strong style="font-size: 1.2em;">${key}:</strong>`; // Set the key
    customFieldsContainer.appendChild(fieldElement);

    // Split the value by newline characters
    const lines = value.split('\n');

    // Initialize a counter for numbered lists
    let numberedListCounter = 1; // Counter for numbered lists

    // Process each line
    lines.forEach(line => {
      if (line.startsWith('(-)')) {
        // Create a list item for lines starting with "(-)"
        const listItem = document.createElement('li');
        listItem.innerHTML = formatText(line.substring(3).trim()); // Remove '(-)' and trim
        listItem.style.listStyleType = 'disc'; // Add bullet point
        listItem.style.marginLeft = '20px'; // Add left padding
        listItem.style.paddingLeft = '5px'; // Add padding between bullet and text
        customFieldsContainer.appendChild(listItem);
      } else if (line.startsWith('(#)')) {
        // Create a numbered list item for lines starting with "(#)"
        const listItem = document.createElement('li');
        listItem.innerHTML = formatText(line.substring(3).trim()); // Remove '(#)' and trim
        listItem.style.listStyleType = 'decimal'; // Set to decimal for numbered list

        // Create a new <ol> for the numbered list if it's the first item
        if (numberedListCounter === 1) {
          const numberedList = document.createElement('ol');
          numberedList.style.listStyleType = 'decimal'; // Ensure decimal style
          numberedList.style.marginLeft = '20px'; // Adjust margin for ordered list
          numberedList.style.paddingLeft = '0'; // Remove padding to avoid extra space
          customFieldsContainer.appendChild(numberedList); // Append the ordered list to the container
        }

        // Append the list item to the numbered list
        const numberedList = customFieldsContainer.lastChild; // Get the last child (the ordered list)
        numberedList.appendChild(listItem); // Append the item to the ordered list
        numberedListCounter++; // Increment the counter
      } else {
        // Create a regular paragraph for other lines
        const textElement = document.createElement('p');
        textElement.innerHTML = formatText(line.trim());
        customFieldsContainer.appendChild(textElement);
      }
    });
  }
}


   document.getElementById('popup-tags').innerHTML = `<strong style="font-size: 1.2em;">Tags:</strong><br>${tileData.tags.join(', ')}`;
   
   // Remove any previous event listener for the popup button
   const popupButton = document.getElementById('popup-button');
   const newPopupButton = popupButton.cloneNode(true);
   popupButton.replaceWith(newPopupButton);
   
   // Add a new event listener for the popup button
   newPopupButton.addEventListener('click', function() {
      window.open(tileData.link, '_blank'); // Open link in new tab
   });
   
   updateTileOutline(characterPopup, tileData.tags);
   
   if (isBlurred && (tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn') || tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞'))) {
      popupImage.classList.add('blurred-image');
   } else {
      popupImage.classList.remove('blurred-image');
   }
   
   // Display the character popup
   characterPopup.classList.remove('hidden');
   document.getElementById('character-popup').style.display = 'block';
   document.getElementById('popup-overlay').style.display = 'block';
}

// Modify the closePopup function
function closePopup() {
   document.getElementById('popup-overlay').style.display = 'none';
   document.getElementById('character-popup').style.display = 'none';
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   characterPopup.classList.add('hidden');
   characterPopup.classList.remove('nsfw-outline');
   popupImage.classList.remove('blurred-image');
}

// Event listener for the random character button
randomCharacterBtn.addEventListener('click', () => {
    // Check if any character has the NSFW tag
    const hasNSFWCharacter = tiles.some(tile => tile.tags.includes('NSFW') || tile.tags.includes('18+') || tile.tags.includes('Porn') || tile.tags.includes('Hentai') || tile.tags.includes('Yaoi') || tile.tags.includes('🔞'));
    
    // Check if all tiles have the NSFW tag
    const allTilesNSFW = tiles.every(tile => tile.tags.includes('NSFW') || tile.tags.includes('18+') || tile.tags.includes('Porn') || tile.tags.includes('Hentai') || tile.tags.includes('Yaoi') || tile.tags.includes('🔞'));

    if (!hasNSFWCharacter) {
        // If no NSFW characters exist, select a random character
        selectRandomCharacter();
    } else if (allTilesNSFW) {
        // If all tiles are NSFW, select a random character
        includeNSFW = true;
        selectRandomCharacter();
    } else if (rememberNSFWChoice) {
        // If the NSFW choice is remembered, select a random character
        selectRandomCharacter();
    } else {
        // Show NSFW inclusion popup if NSFW characters exist and choice is not remembered
        document.getElementById('nsfw-inclusion-popup').style.display = 'flex';
        document.getElementById('popup-overlay').style.display = 'block';
    }
});



// Update the checkbox state based on the saved choice
document.getElementById('remember-nsfw-state-checkbox').checked = rememberNSFWChoice;

document.getElementById('remember-nsfw-state-checkbox').addEventListener('change', (event) => {
   rememberNSFWChoice = event.target.checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
});

document.getElementById('include-nsfw-btn').addEventListener('click', () => {
   includeNSFW = true;
   rememberNSFWChoice = document.getElementById('remember-nsfw-state-checkbox').checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   selectRandomCharacter();
});

document.getElementById('exclude-nsfw-btn').addEventListener('click', () => {
   includeNSFW = false;
   rememberNSFWChoice = document.getElementById('remember-nsfw-state-checkbox').checked;
   localStorage.setItem('rememberNSFWChoice', rememberNSFWChoice); // Save to localStorage
   document.getElementById('nsfw-inclusion-popup').style.display = 'none';
   selectRandomCharacter();
});


// Event listener for the reroll button
document.getElementById('reroll-btn').addEventListener('click', selectRandomCharacter);

function checkForSpecialTiles() {
   const tileElements = document.querySelectorAll('.image-item:not(.add-image)');
   tileElements.forEach((tileElement, index) => {
      const tileData = tiles[index];
      if (
         (tileData.tags.includes('18+') || tileData.tags.includes('NSFW') || tileData.tags.includes('Hentai') || tileData.tags.includes('Porn')|| tileData.tags.includes('Yaoi') || tileData.tags.includes('🔞')) &&
         (tileData.tags.includes('⭐') || tileData.tags.includes('✨') || tileData.tags.includes('🌠') || tileData.tags.includes('🌟') ||
          tileData.tags.includes('💫') || tileData.tags.includes('🤩') || tileData.tags.includes('❇️') || tileData.tags.includes('✴️') ||
          tileData.tags.includes('✳️') || tileData.tags.includes('🔥') || tileData.tags.includes('💎'))
      ) {
         tileElement.classList.add('special-outline');
      } else {
         tileElement.classList.remove('special-outline');
      }
   });
}



// Function to apply blur status on page load
function applyBlurNSFWStatus() {
   const nsfwTags = ['18+', 'NSFW', "Hentai", "Porn", "Yaoi", "🔞"]; // Tags considered NSFW
   const imageItems = document.querySelectorAll('.image-item');

   imageItems.forEach(item => {
      const tags = Array.from(item.querySelectorAll('.tag')).map(tag => tag.textContent);

      if (nsfwTags.some(tag => tags.includes(tag))) {
         const img = item.querySelector('img');
         img.style.filter = isBlurred ? 'blur(10px)' : 'none'; // Apply or remove blur
      }
   });

   blurNSFWBtn.textContent = isBlurred ? 'Unblur NSFW' : 'Blur NSFW'; // Set button text based on status
}


// Define font weight options
const fontWeightOptions = [400, 500, 600, 700, 800, 900];
let currentFontWeightIndex = 0;

// Load font weight from localStorage when the page loads
function loadFontWeight() {
    const savedIndex = localStorage.getItem('fontweightindex');
    if (savedIndex !== null) {
        currentFontWeightIndex = parseInt(savedIndex);
        applyFontWeight();
    }
}

// Save the current font weight index in localStorage
function saveFontWeight() {
    localStorage.setItem('fontweightindex', currentFontWeightIndex.toString());
}

// Apply the current font weight to all relevant elements
function applyFontWeight() {
    const elements = document.querySelectorAll('#tag-filter-mobile, #increase-weight, #tileSize, #tag-filter, #colorSelector, #theme-dropdown-accessibility, li, p, strong, h2, h3, button, tags, span, tag, #font-dropdown');
    const currentWeight = fontWeightOptions[currentFontWeightIndex];

    elements.forEach((element) => {
        element.style.fontWeight = currentWeight; // Apply font weight directly
    });

    // Dynamically update the CSS for the "test" class with !important
    const styleElement = document.getElementById('dynamic-font-weight-style') || document.createElement('style');
    styleElement.id = 'dynamic-font-weight-style';
    styleElement.innerHTML = `.test { font-weight: ${currentWeight} !important; }`;

    document.head.appendChild(styleElement); // Ensure it is added to the document
}

// Increase font weight
function increaseFontWeight() {
    if (currentFontWeightIndex < fontWeightOptions.length - 1) {
        currentFontWeightIndex++;
        applyFontWeight();
        saveFontWeight();
    }
}

// Decrease font weight
function decreaseFontWeight() {
    if (currentFontWeightIndex > 0) {
        currentFontWeightIndex--;
        applyFontWeight();
        saveFontWeight();
    }
}

// Set maximum font weight
function setMaxFontWeight() {
    currentFontWeightIndex = fontWeightOptions.length - 1;
    applyFontWeight();
    saveFontWeight();
}

// Remove custom font weight
function removeFontWeight() {
    const elements = document.querySelectorAll('#increase-weight, #tileSize, #tag-filter, #colorSelector, #theme-dropdown-accessibility, li, p, strong, h3, button, tags, span, tag, #font-dropdown');
    elements.forEach((element) => {
        element.style.removeProperty('font-weight');
    });

    // Remove the font weight for the "test" class
    const styleElement = document.getElementById('dynamic-font-weight-style');
    if (styleElement) {
        styleElement.innerHTML = `.test { font-weight: normal !important; }`; // Reset to normal weight
    }

    localStorage.removeItem('fontweightindex');
    currentFontWeightIndex = 0;
}


// Event listeners
document.getElementById('increase-weight').addEventListener('click', increaseFontWeight);
document.getElementById('decrease-weight').addEventListener('click', decreaseFontWeight);

// Initialize
loadFontWeight();

// Add event listener to the button
blurNSFWBtn.addEventListener('click', toggleBlurNSFW);


document.getElementById('flush-button').addEventListener('click', () => {
    rememberNSFWChoice = false;
    includeNSFW = false;  // Set to false instead of true
    document.getElementById('remember-nsfw-state-checkbox').checked = false;
    localStorage.setItem('rememberNSFWChoice', JSON.stringify(rememberNSFWChoice));
    localStorage.setItem('includeNSFW', JSON.stringify(includeNSFW));
});



// Apply the saved position when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', applySavedPosition);

// Load the saved tile size from local storage on page load
window.addEventListener('DOMContentLoaded', function() {
    const savedSize = localStorage.getItem('tileSize') || 'medium'; // Default to 'medium' if no value is found
    tileSizeSelector.value = savedSize; // Set the dropdown to the saved value
    setTileSize(savedSize); // Apply the saved size to the grid
});

// Call this function when the page loads
window.onload = loadSelectedColorOption;
document.addEventListener('DOMContentLoaded', loadSelectedColorOption);

// On page load, apply the saved toggle state from localStorage
document.addEventListener('DOMContentLoaded', function() {
    const editButtons = document.querySelectorAll('.edit-image-btn');
    const editURL = document.querySelectorAll('.edit-url-btn');
    const editTags = document.querySelectorAll('.edit-tags-btn');
    const editInfo = document.querySelectorAll('.edit-info-btn');
    const editDelete = document.querySelectorAll('.delete-btn');
    const toggleButton = document.getElementById('toggleButton');

    // Get the saved state from localStorage
    const isHidden = localStorage.getItem('buttonsHidden') === 'true';

    // Function to apply the display state
    const setDisplay = (buttons, display) => {
        buttons.forEach(button => {
            button.style.display = display;
        });
    };

    // Apply the saved state to the buttons
    setDisplay(editButtons, isHidden ? 'none' : 'flex');
    setDisplay(editURL, isHidden ? 'none' : 'flex');
    setDisplay(editTags, isHidden ? 'none' : 'flex');
    setDisplay(editInfo, isHidden ? 'none' : 'flex');
    setDisplay(editDelete, isHidden ? 'none' : 'flex');

    // Set the toggle button text based on the state
    toggleButton.textContent = isHidden ? 'Show Tile Buttons' : 'Hide Tile Buttons';
});

// Apply blur status when the page loads
document.addEventListener('DOMContentLoaded', applyBlurNSFWStatus);

// Run the check once on page load
document.addEventListener('DOMContentLoaded', checkForSpecialTiles);


let animationsEnabled = localStorage.getItem('animationsEnabled') === 'true'; // Retrieve saved state from local storage

// Set the initial button text based on the saved state
document.getElementById('toggle-animations').textContent = animationsEnabled ? 'Toggle Animations Off' : 'Toggle Animations On';

// Function to apply or remove the 'no-animation' class based on the animation state
function applyAnimationState() {
    const popups = [
        '.popup',
        '.edit-popup',
        '#image-popup',
        '#image-source-popup',
        '#url-input-popup',
        '#url-popup',
        '#new-image-confirmation-popup',
        '#share-url-popup',
        '#nsfw-inclusion-popup',
        '#settings-popup',
        '.links-popup',
        '#accessibility-popup',
        '#multi-links-popup',
        '#formatting-guide'
    ];

    popups.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            if (animationsEnabled) {
                el.classList.remove('no-animation');
            } else {
                el.classList.add('no-animation');
            }
        });
    });
}

// Apply the saved animation state on page load
applyAnimationState();

document.getElementById('toggle-animations').addEventListener('click', function() {
    // Toggle the animation state
    animationsEnabled = !animationsEnabled;

    // Save the new state to local storage
    localStorage.setItem('animationsEnabled', animationsEnabled);

    // Update the button text
    this.textContent = animationsEnabled ? 'Toggle Animations Off' : 'Toggle Animations On';

    // Apply the updated animation state
    applyAnimationState();
});





// Function to apply the selected font
function applyFont(font) {
    const fonts = {
        "Roboto": "https://fonts.googleapis.com/css2?family=Roboto&display=swap",
        "Open Sans": "https://fonts.googleapis.com/css2?family=Open+Sans&display=swap",
        "Lato": "https://fonts.googleapis.com/css2?family=Lato&display=swap",
        "Montserrat": "https://fonts.googleapis.com/css2?family=Montserrat&display=swap",
        "Poppins": "https://fonts.googleapis.com/css2?family=Poppins&display=swap",
        "Arial": "https://fonts.googleapis.com/css2?family=Arial&display=swap", // Note: Arial is generally a system font
        "Oswald": "https://fonts.googleapis.com/css2?family=Oswald&display=swap",
        "Slabo 27px": "https://fonts.googleapis.com/css2?family=Slabo+27px&display=swap",
        "Source Sans Pro": "https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap",
        "Nunito": "https://fonts.googleapis.com/css2?family=Nunito&display=swap",
        "Merriweather": "https://fonts.googleapis.com/css2?family=Merriweather&display=swap",
        "Dancing Script": "https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap",
        "Lora": "https://fonts.googleapis.com/css2?family=Lora&display=swap",
        "Playfair Display": "https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap",
        "Raleway": "https://fonts.googleapis.com/css2?family=Raleway&display=swap",
        "Cabin": "https://fonts.googleapis.com/css2?family=Cabin&display=swap",
        "Rubik": "https://fonts.googleapis.com/css2?family=Rubik&display=swap",
        "Josefin Sans": "https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap",
        "Titillium Web": "https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap",
        "Bebas Neue": "https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap",
        "Cinzel": "https://fonts.googleapis.com/css2?family=Cinzel&display=swap",
        "Anton": "https://fonts.googleapis.com/css2?family=Anton&display=swap",
        "Fjalla One": "https://fonts.googleapis.com/css2?family=Fjalla+One&display=swap",
        "Quicksand": "https://fonts.googleapis.com/css2?family=Quicksand&display=swap",
        "Karla": "https://fonts.googleapis.com/css2?family=Karla&display=swap",
        "Inconsolata": "https://fonts.googleapis.com/css2?family=Inconsolata&display=swap",
        "Varela Round": "https://fonts.googleapis.com/css2?family=Varela+Round&display=swap",
        "Coda": "https://fonts.googleapis.com/css2?family=Coda&display=swap",
        "Zilla Slab": "https://fonts.googleapis.com/css2?family=Zilla+Slab&display=swap",
        "Noto Sans": "https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap",
        "Fira Sans": "https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap",
        "Roboto Condensed": "https://fonts.googleapis.com/css2?family=Roboto+Condensed&display=swap",
        "Oxygen": "https://fonts.googleapis.com/css2?family=Oxygen&display=swap",
        "Muli": "https://fonts.googleapis.com/css2?family=Muli&display=swap",
        "Lobster": "https://fonts.googleapis.com/css2?family=Lobster&display=swap",
        "Amatic SC": "https://fonts.googleapis.com/css2?family=Amatic+SC&display=swap",
        "Permanent Marker": "https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap"
    };

    // Update the font link in the head
    const fontLink = document.getElementById('font-link');
    fontLink.href = fonts[font];

    // Change the font of the body and specified elements
    document.body.style.fontFamily = font;

    const elementsToUpdate = [
        '.theme-toggle button', 
        '#tag-filter', 
        '#tag-filter-mobile', 
        '#export-btn',
        '#acccessibility-btn1', 
        '#settings-btn1',
        '#flush-button',
        '#optToggleButton',
        '#settings-btn2',
        '#import-btn', 
        '#tile-size', 
        '#colorSelector', 
        '#popup-button', 
        '#reroll-btn', 
        '#local-upload-btn', 
        '#url-upload-btn',
        '#url-popup-close', 
        '#url-popup-close-url', 
        '#local-image-btn', 
        '#url-image-btn', 
        '#urlURL-popup-close', 
        '#url-popup-close-url1', 
        '#popup-close', 
        '.collapsible', 
        '.edit-popup button',
        '#submit-url-btn', 
        '#submit-url-btn1', 
        '#share-url-popup button', 
        '#nsfw-inclusion-popup button', 
        '#image-upload-choice-popup button', 
        '#tile-creation-popup button', 
        '#settings-popup button', 
        '#tileSize', 
        '#undo-delete-popup button', 
        '#popup-close-btn', 
        '#new-confirm-image-btn', 
        '#confirm-image-btn', 
        '#new-cancel-image-btn', 
        '#cancel-image-btn', 
        '#image-confirmation-popup button',
        '#new-image-confirmation-popup button', 
        '.link-button', 
        '#close-links-popup', 
        '#accessibility-popup button', 
        '#theme-dropdown-accessibility', 
        '#close-multi-links-popup', 
        '#font-dropdown'
    ];

    elementsToUpdate.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(element => {
            element.style.fontFamily = font;
        });
    });
}

// Event listener for font dropdown change
document.getElementById('font-dropdown').addEventListener('change', function () {
    const selectedFont = this.value;
    console.log(`Selected font: ${selectedFont}`); // Debug log

    // Save the selected font to local storage
    localStorage.setItem('selectedFont', selectedFont);
    console.log(`Font saved to local storage: ${localStorage.getItem('selectedFont')}`); // Debug log

    // Apply the selected font
    applyFont(selectedFont);
});

// Load the selected font from local storage on page load
window.onload = function() {
    const savedFont = localStorage.getItem('selectedFont');
    console.log(`Loaded font from local storage: ${savedFont}`); // Debug log
    if (savedFont) {
        // Set the dropdown value to the saved font
        document.getElementById('font-dropdown').value = savedFont;
        // Apply the saved font
        applyFont(savedFont);
    }
};

window.onload = function() {
    const keysToCheck = [
        'isBlurred',
        'theme',
        'addImagePosition',
        'selectedColorOption',
        'tileSize',
        'tagsVisible',
        'fontSize',
        'fontweightindex',
        'accessTheme',
        'selectedFont',
        'animationsEnabled'
    ];

    keysToCheck.forEach(key => {
        const value = localStorage.getItem(key);
        if (value === "undefined" || value === "NaN") {
            localStorage.removeItem(key);
        }
    });
};

    </script>
</body>
</html>